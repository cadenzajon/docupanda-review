/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
	'/': {
		parameters: {
			query?: never
			header?: never
			path?: never
			cookie?: never
		}
		/** Root */
		get: operations['root']
		put?: never
		post?: never
		delete?: never
		options?: never
		head?: never
		patch?: never
		trace?: never
	}
	'/health': {
		parameters: {
			query?: never
			header?: never
			path?: never
			cookie?: never
		}
		get?: never
		put?: never
		/**
		 * Health Check
		 * @description Health check endpoint to confirm the service is operational.
		 */
		post: operations['health_check']
		delete?: never
		options?: never
		head?: never
		patch?: never
		trace?: never
	}
	'/document': {
		parameters: {
			query?: never
			header?: never
			path?: never
			cookie?: never
		}
		get?: never
		put?: never
		/**
		 * Submit a Document for Processing
		 * @description Use this endpoint to submit a document to DocuPanda for processing. You can upload a local file or provide a URL to a remote file. Upon submission, receive a unique `documentId` which you may use to retrieve the document's results, or apply subsequent workflows on it.
		 *
		 *     Max document size is 500 pages and 1000 MB.
		 *
		 *     *Advanced*: you may also provide a `workflowId` to apply a pre-defined workflow to the document.
		 */
		post: operations['post_document']
		delete?: never
		options?: never
		head?: never
		patch?: never
		trace?: never
	}
	'/document/{document_id}/proposed-schemas': {
		parameters: {
			query?: never
			header?: never
			path?: never
			cookie?: never
		}
		/**
		 * Get Schema Proposals
		 * @description Get schema proposals for a document by providing the document's ID. The schema proposals are generated by the AI based on the document's content.
		 */
		get: operations['get_proposed_schemas']
		put?: never
		post?: never
		delete?: never
		options?: never
		head?: never
		patch?: never
		trace?: never
	}
	'/document/{document_id}': {
		parameters: {
			query?: never
			header?: never
			path?: never
			cookie?: never
		}
		/**
		 * Retrieve a Processed Document
		 * @description Access the analysis results of your submitted document using this endpoint. The `status` field indicates the document's current processing stage, and the `result` field provides the extracted plain text for AI comprehension, as well as more granular structured information such as bounding boxes for detected tables and text blocks.
		 */
		get: operations['get_document']
		put?: never
		post?: never
		/**
		 * Delete a Document
		 * @description Delete a document that has been previously submitted to DocuPanda for processing.
		 */
		delete: operations['delete_document']
		options?: never
		head?: never
		patch?: never
		trace?: never
	}
	'/document/{document_id}/download/original-url': {
		parameters: {
			query?: never
			header?: never
			path?: never
			cookie?: never
		}
		/**
		 * Download Original URL
		 * @description Generate and retrieve a presigned URL for accessing the original file of a document by its ID. The URL is valid for a limited time (e.g., 1 hour) and allows secure access to the document stored on DocuPanda.
		 */
		get: operations['download_original_url']
		put?: never
		post?: never
		delete?: never
		options?: never
		head?: never
		patch?: never
		trace?: never
	}
	'/document/{document_id}/download/ocr-url': {
		parameters: {
			query?: never
			header?: never
			path?: never
			cookie?: never
		}
		/**
		 * Download OCR URL
		 * @description Generate an OCR PDF by providing a document ID. This will add the OCR text into a layer on top of the PDF, allowing you to search the PDF by the OCR text. Returns a presigned URL to download the OCR PDF. This URL is valid for a limited time (e.g., 1 hour) and allows secure access to the OCR PDF stored on DocuPanda. Note that this endpoint only works for documents with PDF file types.
		 */
		get: operations['download_ocr_url']
		put?: never
		post?: never
		delete?: never
		options?: never
		head?: never
		patch?: never
		trace?: never
	}
	'/documents': {
		parameters: {
			query?: never
			header?: never
			path?: never
			cookie?: never
		}
		/**
		 * List Documents
		 * @description List all documents that have been submitted to DocuPanda for processing. You can filter the results by providing a dataset name.
		 */
		get: operations['list_documents']
		put?: never
		post?: never
		/**
		 * Delete Multiple Documents
		 * @description Delete multiple documents that have been previously submitted to DocuPanda for processing. You can provide a list of document IDs to delete multiple documents at once.
		 */
		delete: operations['delete_documents']
		options?: never
		head?: never
		patch?: never
		trace?: never
	}
	'/dataset-names': {
		parameters: {
			query?: never
			header?: never
			path?: never
			cookie?: never
		}
		/**
		 * List Dataset Names
		 * @description List all dataset names for the documents you have submitted so far
		 */
		get: operations['list_datasets']
		put?: never
		post?: never
		delete?: never
		options?: never
		head?: never
		patch?: never
		trace?: never
	}
	'/documents/update-dataset': {
		parameters: {
			query?: never
			header?: never
			path?: never
			cookie?: never
		}
		get?: never
		put?: never
		/**
		 * Update Dataset
		 * @description Update the dataset of a list of documents by providing a list of document IDs and the new dataset name. This operation will update the dataset of all documents and standardizations associated with those documents.
		 */
		post: operations['update_documents_dataset']
		delete?: never
		options?: never
		head?: never
		patch?: never
		trace?: never
	}
	'/schema/refine': {
		parameters: {
			query?: never
			header?: never
			path?: never
			cookie?: never
		}
		get?: never
		put?: never
		/**
		 * Refine a Schema
		 * @description Refine a schema by providing feedback in free text to edit the structured output.
		 */
		post: operations['post_refine_schema']
		delete?: never
		options?: never
		head?: never
		patch?: never
		trace?: never
	}
	'/schema/autogenerate': {
		parameters: {
			query?: never
			header?: never
			path?: never
			cookie?: never
		}
		get?: never
		put?: never
		/**
		 * AutoGenerate a Schema
		 * @description Generate a schema based on a list of documents. Leave the instructions empty if you want the AI to use its best judgment, or provide instructions to indicate your preference to how the schema should be generated. Best results are achieved when you provide a varied list of documents that represent the full range of type of documents you expect to process, and when you provide clear instructions to what you expect the schema to capture and how you want it to be structured.
		 */
		post: operations['post_schema_autogenerate']
		delete?: never
		options?: never
		head?: never
		patch?: never
		trace?: never
	}
	'/schema/autogenerate/{job_id}': {
		parameters: {
			query?: never
			header?: never
			path?: never
			cookie?: never
		}
		/**
		 * Retrieve AutoGenerate Schema Job
		 * @description Retrieve the status of an autogenerate schema job.
		 */
		get: operations['get_schema_autogenerate_job']
		put?: never
		post?: never
		delete?: never
		options?: never
		head?: never
		patch?: never
		trace?: never
	}
	'/schema/{schema_id}': {
		parameters: {
			query?: never
			header?: never
			path?: never
			cookie?: never
		}
		/**
		 * Retrieve a Schema
		 * @description Retrieve an existing schema by providing the schema's ID.
		 */
		get: operations['get_schema']
		put?: never
		post?: never
		/**
		 * Delete a Schema
		 * @description Delete a schema by its id.
		 */
		delete: operations['delete_schema']
		options?: never
		head?: never
		patch?: never
		trace?: never
	}
	'/schemas': {
		parameters: {
			query?: never
			header?: never
			path?: never
			cookie?: never
		}
		/**
		 * List Schemas
		 * @description List all of your schemas. The output here includes the jsonSchema data as well.
		 */
		get: operations['list_schemas']
		put?: never
		post?: never
		delete?: never
		options?: never
		head?: never
		patch?: never
		trace?: never
	}
	'/standardization/{standardization_id}': {
		parameters: {
			query?: never
			header?: never
			path?: never
			cookie?: never
		}
		/**
		 * Retrieve a Standardization JSON
		 * @description Retrieve the standardization results of a document as a JSON object.
		 */
		get: operations['get_standardization']
		put?: never
		post?: never
		/**
		 * Delete a Standardization
		 * @description Delete a standardization by providing the standardization ID.
		 */
		delete: operations['delete_standardization']
		options?: never
		head?: never
		patch?: never
		trace?: never
	}
	'/standardization/{standardization_id}/xml': {
		parameters: {
			query?: never
			header?: never
			path?: never
			cookie?: never
		}
		/**
		 * Retrieve a Standardization XML
		 * @description Retrieve the standardization results of a document as an XML object.
		 */
		get: operations['get_standardization_xml']
		put?: never
		post?: never
		delete?: never
		options?: never
		head?: never
		patch?: never
		trace?: never
	}
	'/standardization/{standardization_id}/download/excel-url': {
		parameters: {
			query?: never
			header?: never
			path?: never
			cookie?: never
		}
		/**
		 * Download Excel URL
		 * @description Generate an Excel file from the standardization JSON by providing a standardization ID. All arrays in the JSON will be put in a separate sheet, and all the non-array fields will be put in the main sheet. Returns a presigned URL to download the Excel file. This URL is valid for a limited time (e.g., 1 hour) and allows secure access to the Excel file stored on DocuPanda.
		 */
		get: operations['download_excel_url']
		put?: never
		post?: never
		delete?: never
		options?: never
		head?: never
		patch?: never
		trace?: never
	}
	'/standardizations': {
		parameters: {
			query?: never
			header?: never
			path?: never
			cookie?: never
		}
		/**
		 * List Standardizations
		 * @description Retrieve all standardizations of documents that have been processed using a specific schema.
		 */
		get: operations['list_standardizations']
		put?: never
		post?: never
		/**
		 * Delete Multiple Standardizations
		 * @description Delete multiple standardizations at once by providing a list of standardization IDs.
		 */
		delete: operations['delete_standardizations']
		options?: never
		head?: never
		patch?: never
		trace?: never
	}
	'/jobs': {
		parameters: {
			query?: never
			header?: never
			path?: never
			cookie?: never
		}
		/**
		 * List Jobs
		 * @description List all jobs that have been submitted to DocuPanda for processing. Every document upload, standardization, or credit-consuming event results in a job. This lets you audit your credit consumption. You can optionally filter the results by providing a date range in the format yyyy-mm-dd.
		 */
		get: operations['list_jobs']
		put?: never
		post?: never
		/**
		 * Delete Jobs
		 * @description Delete multiple jobs that have been submitted to DocuPanda for processing. You can provide a list of job IDs to delete multiple jobs at once. Since jobs are just a record of events, deleting them will just hide them from you - the actual records will still be stored in the database. For specific jobs that contain actual data, such as Analyze-Document, the data will be deleted.
		 */
		delete: operations['delete_jobs']
		options?: never
		head?: never
		patch?: never
		trace?: never
	}
	'/v2/standardize/batch': {
		parameters: {
			query?: never
			header?: never
			path?: never
			cookie?: never
		}
		get?: never
		put?: never
		/**
		 * Standardize Documents
		 * @description Standardize a batch documents, either by passing a list of Document IDs or by passing a dataset name. Pass a schemaId to standardize the documents using a specific structure, or leave it empty to create an ad-hoc structure as the AI sees fit. Standardization handles lists (arrays) by splitting documents into smaller sub-documents behind the scenes - the AI will do its best to decide how and when it is appropriate to split.
		 *
		 *     *Advanced*: You can specify certain parameters, by default they are left to `auto` which lets the AI decide.
		 *     1. `displayMode` - Controls how the AI sees the document. The options are:
		 *        - `auto` - Automatically determine the best mode based on the document content.
		 *        - `spatial` - Represent text in the document according to its spatial layout.
		 *        - `sections` - Represent the document as a list of sections (paragraphs, tables, images, etc.) as seen in the web UX.
		 *     2. `splitMode` - Controls how the AI splits the document into sub-documents. The options are:
		 *        - `auto` - Automatically determine the best mode based on the document content.
		 *        - `all` - Split the document into single-page sub-documents, so each page is handled separately.
		 *        - `never` - Do not split the document at all, so the entire document is handled as a single unit. This can lead to poor performance for long documents, or documents with lots of dense data that needs to be extracted.
		 *     3. `effortLevel` - Controls how much effort the AI puts into the standardization. The options are:
		 *        - `standard` - Use the standard effort level.
		 *        - `high` - Use the high effort level, which takes longer but can produce better results. Costs +2 credits per page.
		 */
		post: operations['post_standardize_batch_v2']
		delete?: never
		options?: never
		head?: never
		patch?: never
		trace?: never
	}
	'/enterprise/matching': {
		parameters: {
			query?: never
			header?: never
			path?: never
			cookie?: never
		}
		get?: never
		put?: never
		/**
		 * Match a standardization to a list of candidates
		 * @description Use this endpoint to match a standardization to a list of candidates. You can provide a standardization id and a list of candidates. A candidate must have and id  and a record which details all its properties. You can optionally provide instructions to clarify the task rules
		 */
		post: operations['match_standardization']
		delete?: never
		options?: never
		head?: never
		patch?: never
		trace?: never
	}
	'/review/batch': {
		parameters: {
			query?: never
			header?: never
			path?: never
			cookie?: never
		}
		get?: never
		put?: never
		/**
		 * Generate a Visual Review
		 * @description This endpoint is used to generate a visual review of the standardization results. For every value in the standardization payload, we generate a confidence score and a a list of locations, where a location is page number and x1,y1,x2,y2 bounding box coordinate on that page, designating the top left and lower right corner of the bounding box. This indicates where in the doucment the value was found.
		 */
		post: operations['post_review_batch']
		delete?: never
		options?: never
		head?: never
		patch?: never
		trace?: never
	}
	'/review': {
		parameters: {
			query?: never
			header?: never
			path?: never
			cookie?: never
		}
		/**
		 * Retrieve a Review
		 * @description This endpoint is used to retrieve a review object by either by its unique identifier or by its associated standardization ID.
		 */
		get: operations['get_standardization_review']
		put?: never
		post?: never
		delete?: never
		options?: never
		head?: never
		patch?: never
		trace?: never
	}
	'/reviews': {
		parameters: {
			query?: never
			header?: never
			path?: never
			cookie?: never
		}
		/**
		 * List Reviews
		 * @description This endpoint is used to list all review objects.
		 */
		get: operations['list_reviews']
		put?: never
		post?: never
		/**
		 * Delete Reviews
		 * @description This endpoint is used to delete multiple review object. You can pass a length 1 list of review IDs to delete a single review.
		 */
		delete: operations['delete_reviews']
		options?: never
		head?: never
		patch?: never
		trace?: never
	}
	'/schema': {
		parameters: {
			query?: never
			header?: never
			path?: never
			cookie?: never
		}
		get?: never
		put?: never
		/**
		 * Add a Schema
		 * @description Create a new schema by posting a valid JSON schema. The schema should be a valid JSON schema that represents the structured output you want to extract from documents.
		 */
		post: operations['post_schema']
		delete?: never
		options?: never
		head?: never
		patch?: never
		trace?: never
	}
	'/schema/update': {
		parameters: {
			query?: never
			header?: never
			path?: never
			cookie?: never
		}
		get?: never
		put?: never
		/**
		 * Update a Schema
		 * @description Update an existing schema by posting a valid JSON schema. This does not overwrite, but creates a new schema.
		 */
		post: operations['post_update_schema']
		delete?: never
		options?: never
		head?: never
		patch?: never
		trace?: never
	}
	'/schema/edit': {
		parameters: {
			query?: never
			header?: never
			path?: never
			cookie?: never
		}
		get?: never
		put?: never
		/**
		 * Edit a Schema
		 * @description Edit a schema by providing a schema ID and the parameters you want to edit. This does not create a new schema, but rather updates the existing schema. Changing the schema name is purely cosmetic, but changing the description and guidelines will affect the behavior of the schema for future standardizations. The things you can edit are:
		 *
		 *     1. `schemaName` - The name of the schema
		 *     2. `description` - The description of the schema
		 *     3. `guidelines` - The guidelines for the schema
		 */
		post: operations['post_edit_schema']
		delete?: never
		options?: never
		head?: never
		patch?: never
		trace?: never
	}
	'/class': {
		parameters: {
			query?: never
			header?: never
			path?: never
			cookie?: never
		}
		get?: never
		put?: never
		/**
		 * Add a Class
		 * @description Add a new class to the taxonomy of classes, including name and description.
		 */
		post: operations['post_add_class']
		delete?: never
		options?: never
		head?: never
		patch?: never
		trace?: never
	}
	'/class/{class_id}': {
		parameters: {
			query?: never
			header?: never
			path?: never
			cookie?: never
		}
		get?: never
		put?: never
		post?: never
		/**
		 * Delete a Class
		 * @description Delete a class from the taxonomy of classes by providing the class ID.
		 */
		delete: operations['delete_class']
		options?: never
		head?: never
		patch?: never
		trace?: never
	}
	'/classes': {
		parameters: {
			query?: never
			header?: never
			path?: never
			cookie?: never
		}
		/**
		 * List Classes
		 * @description List all classes that have been defined in the taxonomy.
		 */
		get: operations['list_classes']
		put?: never
		post?: never
		delete?: never
		options?: never
		head?: never
		patch?: never
		trace?: never
	}
	'/classify/batch': {
		parameters: {
			query?: never
			header?: never
			path?: never
			cookie?: never
		}
		get?: never
		put?: never
		/**
		 * Classify Documents
		 * @description Classify a batch of one or multiple documents all at once by passing a list of document IDs, and an optional list of class IDs to use for classification. If no class IDs are provided, all classes will be used. To use the `unknown` class, either pass its classId ('unknown') or set the includeUnknown flag as True.
		 */
		post: operations['post_classify_batch']
		delete?: never
		options?: never
		head?: never
		patch?: never
		trace?: never
	}
	'/classify/{job_id}': {
		parameters: {
			query?: never
			header?: never
			path?: never
			cookie?: never
		}
		/**
		 * Retrieve Classification Job
		 * @description Retrieve the status of a classification job, including the outcome of the assigned classes.
		 */
		get: operations['get_classify_job']
		put?: never
		post?: never
		delete?: never
		options?: never
		head?: never
		patch?: never
		trace?: never
	}
	'/analyze/document': {
		parameters: {
			query?: never
			header?: never
			path?: never
			cookie?: never
		}
		get?: never
		put?: never
		/**
		 * Analyze Document
		 * @description Analyze a single document by passing a `documentId` and a list of questions in natural language. If the `pages` parameter is provided, the AI will only analyze the specified pages. Poll for the results using the `GET /job/{jobId}` endpoint with the returned jobId.
		 */
		post: operations['post_analyze_document']
		delete?: never
		options?: never
		head?: never
		patch?: never
		trace?: never
	}
	'/analyze/data': {
		parameters: {
			query?: never
			header?: never
			path?: never
			cookie?: never
		}
		get?: never
		put?: never
		/**
		 * Analyze Data
		 * @description Analyze multiple documents all at once, either by passing a list of Document IDs or by passing a dataset name. If both are pased, we will use the intersection of the two. Analysis works by passing a list of questions in natural language. If a schemaId is passed, the AI will first use the standardizations of those documents under the provided schema to narrow down which documents are relevant. Only then, it will analyze the documents and provide answers to the questions, along with confidence scores and citations.
		 *     If a schemaId is not passed, the AI will manually examine all documents, with a limit of 50.
		 *      When schemaId is passed, the AI can optionally also perform database queries for statistical calculations and         answer the questions based on those results.
		 */
		post: operations['post_analyze_data']
		delete?: never
		options?: never
		head?: never
		patch?: never
		trace?: never
	}
	'/analysis/{analysis_id}': {
		parameters: {
			query?: never
			header?: never
			path?: never
			cookie?: never
		}
		/**
		 * Retrieve Analysis
		 * @description Retrieve an analysis object by providing the analysis ID, which has the questions and answers.
		 */
		get: operations['get_analysis']
		put?: never
		post?: never
		delete?: never
		options?: never
		head?: never
		patch?: never
		trace?: never
	}
	'/analyses': {
		parameters: {
			query?: never
			header?: never
			path?: never
			cookie?: never
		}
		/**
		 * List Analyses
		 * @description List all analyses that have been performed.
		 */
		get: operations['list_analyses']
		put?: never
		post?: never
		/**
		 * Delete Multiple Analyses
		 * @description Delete multiple analyses at once by providing a list of analysis IDs.
		 */
		delete: operations['delete_analyses']
		options?: never
		head?: never
		patch?: never
		trace?: never
	}
	'/split': {
		parameters: {
			query?: never
			header?: never
			path?: never
			cookie?: never
		}
		get?: never
		put?: never
		/**
		 * Split a Document
		 * @description Split a document into multiple documents intelligently using AI. If no splitting is needed, no new documents will be created. Otherwise, the new sub-documents will be automatically generated.
		 */
		post: operations['post_split']
		delete?: never
		options?: never
		head?: never
		patch?: never
		trace?: never
	}
	'/split/{job_id}': {
		parameters: {
			query?: never
			header?: never
			path?: never
			cookie?: never
		}
		/**
		 * Retrieve Split Job
		 * @description Retrieve the status of a document splitting job.
		 */
		get: operations['get_split_job']
		put?: never
		post?: never
		delete?: never
		options?: never
		head?: never
		patch?: never
		trace?: never
	}
	'/query': {
		parameters: {
			query?: never
			header?: never
			path?: never
			cookie?: never
		}
		get?: never
		put?: never
		/**
		 * Query Standardizations
		 * @description Query the documents you have standardized using free form language.The query should be written in plain human language e.g "Find all the documents where the rental is above $1000 in San Francisco".
		 */
		post: operations['post_query']
		delete?: never
		options?: never
		head?: never
		patch?: never
		trace?: never
	}
	'/job/{job_id}': {
		parameters: {
			query?: never
			header?: never
			path?: never
			cookie?: never
		}
		/**
		 * Retrieve a Job
		 * @description Retrieve the details of a specific job by providing the job's ID. This will include the job's status, timestamp, and any other relevant information.
		 */
		get: operations['get_job']
		put?: never
		post?: never
		delete?: never
		options?: never
		head?: never
		patch?: never
		trace?: never
	}
	'/jobs/summary': {
		parameters: {
			query?: never
			header?: never
			path?: never
			cookie?: never
		}
		/**
		 * Get Job Count
		 * @description Get a count of your jobs broken down by Job Type. For each job type, you will see the number of jobs and number of credits consumed. The output includes 3 versions of the summary:
		 *     1. All time summary with deleted jobs
		 *     2. All time summary excluding deleted jobs
		 *     2. Count since start_date (defaults to previous billing date, includes deleted jobs)
		 *     You may pass start_date as an optional query parameter in ISO format (yyyy-mm-dd).
		 */
		get: operations['get_job_summary']
		put?: never
		post?: never
		delete?: never
		options?: never
		head?: never
		patch?: never
		trace?: never
	}
	'/documents/summary': {
		parameters: {
			query?: never
			header?: never
			path?: never
			cookie?: never
		}
		/**
		 * Get Document Count
		 * @description Get a count of your documents, including the total number of documents, as well as the list of unique datasets
		 */
		get: operations['get_document_summary']
		put?: never
		post?: never
		delete?: never
		options?: never
		head?: never
		patch?: never
		trace?: never
	}
	'/standardizations/summary': {
		parameters: {
			query?: never
			header?: never
			path?: never
			cookie?: never
		}
		/**
		 * Get Standardization Count
		 * @description Get a count of your standardizations, including the total number as well as the list of unique schema names
		 */
		get: operations['get_standardization_summary']
		put?: never
		post?: never
		delete?: never
		options?: never
		head?: never
		patch?: never
		trace?: never
	}
	'/account': {
		parameters: {
			query?: never
			header?: never
			path?: never
			cookie?: never
		}
		/**
		 * Get Account Information
		 * @description Get information about your account, including the number of remaining credits, the number of overage credits, and the details of the upcoming invoice.
		 */
		get: operations['get_account']
		put?: never
		post?: never
		delete?: never
		options?: never
		head?: never
		patch?: never
		trace?: never
	}
	'/workflow/on-submit-document': {
		parameters: {
			query?: never
			header?: never
			path?: never
			cookie?: never
		}
		get?: never
		put?: never
		/**
		 * Create a Workflow
		 * @description Use this endpoint to create a workflow that triggers when a document is submitted.
		 *
		 *     The workflow can be configured to either:
		 *     1. Always run the specified schema(s) on the document, set via the `standardizeStep` input.
		 *     2. Conditionally run one or more schemas based on the document's `classId`, set via the `classifyStandardizeStep` input.
		 *
		 *     Note: You must provide one of these inputs, but not both.
		 *
		 *     To run the workflow, use the `POST /document` endpoint with the `workflowId` that gets returned from this endpoint.
		 */
		post: operations['post_workflow_on_submit_document']
		delete?: never
		options?: never
		head?: never
		patch?: never
		trace?: never
	}
	'/workflows': {
		parameters: {
			query?: never
			header?: never
			path?: never
			cookie?: never
		}
		/**
		 * List your Workflows
		 * @description This endpoint returns a list of all your workflows.
		 */
		get: operations['list_workflows']
		put?: never
		post?: never
		delete?: never
		options?: never
		head?: never
		patch?: never
		trace?: never
	}
	'/workflow/{workflow_id}': {
		parameters: {
			query?: never
			header?: never
			path?: never
			cookie?: never
		}
		get?: never
		put?: never
		post?: never
		/**
		 * Delete a Workflow
		 * @description Delete a workflow by providing the workflow ID.
		 */
		delete: operations['delete_workflow']
		options?: never
		head?: never
		patch?: never
		trace?: never
	}
	'/webhook/get-portal-link': {
		parameters: {
			query?: never
			header?: never
			path?: never
			cookie?: never
		}
		/**
		 * Get Webhook Portal URL
		 * @description Generates a magic link for you to log on to URL to the app portal. From the portal you can configure webhook subscriptions in a user-friendly interface.
		 */
		get: operations['get_portal_link']
		put?: never
		post?: never
		delete?: never
		options?: never
		head?: never
		patch?: never
		trace?: never
	}
	'/webhook/generate-endpoint': {
		parameters: {
			query?: never
			header?: never
			path?: never
			cookie?: never
		}
		get?: never
		put?: never
		/**
		 * Register an Endpoint
		 * @description Generate a webhook endpoint for your application. The specified url will receive ALL events. If you want to define a more granular specification, use our dashboard portal under account/settings in docupanda website.
		 */
		post: operations['generate_endpoint']
		delete?: never
		options?: never
		head?: never
		patch?: never
		trace?: never
	}
	'/webhook/delete-endpoint': {
		parameters: {
			query?: never
			header?: never
			path?: never
			cookie?: never
		}
		get?: never
		put?: never
		/**
		 * Deregister an Endpoint
		 * @description Deregister a webhook endpoint for your application, it will stop receiving all events. You can also manage this in our dashboard portal under account/settings in docupanda website.
		 */
		post: operations['delete_endpoint']
		delete?: never
		options?: never
		head?: never
		patch?: never
		trace?: never
	}
	'/readme-webhook': {
		parameters: {
			query?: never
			header?: never
			path?: never
			cookie?: never
		}
		get?: never
		put?: never
		/**
		 * Webhook Readme
		 * @description readme.io webhook to let them know what's a user's secret key
		 */
		post: operations['webhook_readme']
		delete?: never
		options?: never
		head?: never
		patch?: never
		trace?: never
	}
}
export type webhooks = Record<string, never>
export interface components {
	schemas: {
		/** AddUpdateSchemaResponse */
		AddUpdateSchemaResponse: {
			/**
			 * Success
			 * @description Whether the schema was successfully added.
			 */
			success: boolean
			/**
			 * Schema ID
			 * @description Unique identifier of the new schema.
			 */
			schemaId: string
			/**
			 * Job ID
			 * @description Unique identifier of the job that made the schema.
			 */
			jobId: string
			/**
			 * Timestamp
			 * @description Timestamp of the creation of the schema.
			 */
			timestamp: string
		}
		/**
		 * Analysis
		 * @description Public facing version of DocuPandaAnalysis
		 *
		 */
		Analysis: {
			/**
			 * Analysis ID
			 * @description Unique identifier of the analysis object.
			 */
			analysisId: string
			/**
			 * Job ID
			 * @description Unique identifier of the job that created the analysis.
			 */
			jobId: string
			/**
			 * Document IDs
			 * @description List of document IDs that were analyzed.
			 */
			documentIds?: string[]
			/**
			 * Filename
			 * @description Name of the file that was analyzed, if there is only a single document.
			 */
			filename?: string
			/**
			 * Dataset
			 * @description Dataset which defines what documents are included in the analysis.
			 */
			dataset?: string
			/**
			 * Schema ID
			 * @description Unique identifier of the schema used to fetch standardizations for querying.
			 */
			schemaId?: string
			/**
			 * Number of Documents
			 * @description Number of documents analyzed.
			 */
			numDocs?: number
			/**
			 * Pages
			 * @description List of page numbers to analyze. If none, all pages are analyzed. Only applies for single document.
			 */
			pages?: number[]
			/**
			 * Data (Questions and Answers)
			 * @description List of questions and answers for the analysis, along with confidence and citations.
			 */
			data: components['schemas']['QuestionAnswer'][]
			/**
			 * Timestamp
			 * @description Timestamp of the analysis job.
			 */
			timestamp?: string
		}
		/**
		 * AnalyzeDataRequest
		 * @description Asyncronous request for the Analyze Data endpoint
		 *
		 */
		AnalyzeDataRequest: {
			/**
			 * Document IDs
			 * @description List of document IDs to analyze. If both dataset and documentIds are provided, we take the intersection of the two.
			 */
			documentIds?: string[]
			/**
			 * Dataset
			 * @description Dataset which defines what documents are included in the analysis. If both dataset and documentIds are provided, we take the intersection of the two.
			 */
			dataset?: string
			/**
			 * Schema ID
			 * @description Unique identifier of the schema to be used for the analysis. If provided, only those documents with a valid standardization under this schema will be included in the analysis.
			 */
			schemaId?: string
			/**
			 * Questions
			 * @description List of questions to be answered.
			 */
			questions: string[]
			/**
			 * Max Credits
			 * @description Maximum number of credits to spend on this job. If not provided, no maximum is enforced.
			 */
			maxCredits?: number
		}
		/** AnalyzeDocumentRequest */
		AnalyzeDocumentRequest: {
			/**
			 * Document ID
			 * @description Unique identifier of the document to be questioned.
			 */
			documentId: string
			/**
			 * Questions
			 * @description List of questions to be answered.
			 */
			questions: string[]
			/**
			 * Pages
			 * @description List of page numbers to be analyzed (zero indexed). If not provided, all pages will be analyzed.
			 */
			pages?: number[]
		}
		/**
		 * AnalyzedPage
		 * @description Public facing version of DocuPandaAnalyzedPage
		 *
		 */
		AnalyzedPage: {
			/**
			 * Sections
			 * @description A list of parsed sections in the page.
			 * @default []
			 */
			sections: components['schemas']['Section'][]
			/**
			 * Text
			 * @description The text content of the page - a concatenation of the text in all sections.
			 */
			text?: string
			/**
			 * Page Number
			 * @description The number of this page in document (zero indexed).
			 * @default 0
			 */
			pageNum: number
		}
		/** AutoGenerateSchemaJobResponse */
		AutoGenerateSchemaJobResponse: {
			/**
			 * Job ID
			 * @description Unique identifier for the autogenerate schema job.
			 */
			jobId: string
			/**
			 * Job Status
			 * @description Current status of the job.
			 */
			status: components['schemas']['ProcessingStatus']
			/**
			 * Schema ID
			 * @description Unique identifier for the generated schema. Only available when the job is completed.
			 */
			schemaId?: string
			/**
			 * Standardization IDs
			 * @description List of standardization IDs for the documents used to generate the schema. These will only become available after schema generation is complete, and only if standardizeUsingSchema is set to true.
			 */
			standardizationIds?: string[]
			/**
			 * Error Message
			 * @description Error message if the job failed.
			 */
			errorMessage?: string
		}
		/** AutoGenerateSchemaRequest */
		AutoGenerateSchemaRequest: {
			/**
			 * Schema Name
			 * @description Name of the schema to be defined. For example rental contracts
			 */
			schemaName?: string
			/**
			 * Document IDs
			 * @description List of document IDs to use for schema generation.
			 */
			documentIds?: string[]
			/**
			 * Dataset
			 * @description The dataset to which the documents belong.
			 */
			dataset?: string
			/**
			 * Create Instructions
			 * @description Instructions on how to create the schema.
			 */
			instructions?: string
			/**
			 * Apply Guidelines
			 * @description Guidelines to apply to the schema to documents when standardizing.
			 */
			guidelines?: string
			/**
			 * Standardize Using Schema
			 * @description Whether to standardize the input documents using the newly created schema after generation.Note that standardizing documents costs credits just as if you had called the `/standardize` endpoint directly
			 * @default true
			 */
			standardizeUsingSchema: boolean
			/**
			 * Standardization Mode
			 * @description *Advanced Feature*
			 *     Mode of standardization to run, if standardizing using the schema.
			 */
			standardizationMode?: components['schemas']['StdMode']
		}
		/** AutoGenerateSchemaResponse */
		AutoGenerateSchemaResponse: {
			/**
			 * Job ID
			 * @description Unique identifier for the autogenerate schema job.
			 */
			jobId: string
			/**
			 * Job Status
			 * @description Current status of the job.
			 */
			status: components['schemas']['ProcessingStatus']
			/**
			 * Schema ID
			 * @description Unique identifier for the schema being generated. The schema is only available when the job is completed.
			 */
			schemaId?: string
			/**
			 * Schema Name
			 * @description Name of the schema being generated.
			 */
			schemaName?: string
			/**
			 * Standardization IDs
			 * @description List of standardization IDs for the documents used to generate the schema. These will only become available after schema generation is complete, and only if standardizeUsingSchema is set to true.
			 */
			standardizationIds?: string[]
			/**
			 * Standardization Job IDs
			 * @description List of standardization job IDs for the documents used to generate the schema. These will only become available after schema generation is complete, and only if standardizeUsingSchema is set to true.
			 */
			standardizationJobIds?: string[]
		}
		/** BatchReviewResponse */
		BatchReviewResponse: {
			/**
			 * Job IDs
			 * @description Unique identifiers of the jobs.
			 */
			jobIds: string[]
			/**
			 * Review IDs
			 * @description Unique identifiers of the review objects which will be generated.
			 */
			reviewIds: string[]
			/**
			 * Standardization IDs
			 * @description Unique identifiers of the standardization objects under review.
			 */
			standardizationIds: string[]
		}
		/** Citation */
		Citation: {
			/**
			 * Document ID
			 * @description Unique identifier of the document where the citation is found.
			 */
			documentId: string
			/**
			 * Pages
			 * @description List of page numbers where the citation is found (zero-indexed).
			 */
			pages: number[]
		}
		/** ClassAddRequest */
		ClassAddRequest: {
			/**
			 * Class Name
			 * @description Name of the class to be added.
			 */
			className: string
			/**
			 * Description
			 * @description Description of the class to be added. This will be used by the AI to classify documents.
			 */
			description: string
		}
		/**
		 * ClassObject
		 * @description Public facing version of DocuPandaClass
		 *
		 */
		ClassObject: {
			/**
			 * Class ID
			 * @description Unique identifier of the classification object.
			 */
			classId: string
			/**
			 * Class Name
			 * @description Name of the class.
			 */
			className: string
			/**
			 * Description
			 * @description Description of the class.
			 */
			description?: string
			/**
			 * Timestamp
			 * @description Timestamp of the classification creation.
			 */
			timestamp?: string
		}
		/** ClassifyBatchRequest */
		ClassifyBatchRequest: {
			/**
			 * Document IDs
			 * @description List of document IDs to classify
			 */
			documentIds: string[]
			/**
			 * Class IDs
			 * @description List of class IDs to use for classification
			 */
			classIds?: string[]
			/**
			 * Multi-Class
			 * @description Whether to allow multiple classifications per document
			 * @default false
			 */
			multiClass: boolean
			/**
			 * Include Unknown
			 * @description Whether to include the 'unknown' class in the classification (only relevant if multiClass is false)
			 * @default true
			 */
			includeUnknown: boolean
			/**
			 * Instructions
			 * @description Instructions for the AI on how to classify the documents
			 */
			instructions?: string
		}
		/** ClassifyBatchResponse */
		ClassifyBatchResponse: {
			/**
			 * Job ID
			 * @description ID of the batch classification job
			 */
			jobId: string
			/**
			 * Document Count
			 * @description Number of documents processed
			 */
			documentCount?: number
			/**
			 * Page Count
			 * @description Number of pages processed
			 */
			pageCount?: number
			/**
			 * Classification Job IDs
			 * @description List of individual job IDs for each document's classify job
			 */
			classificationJobIds?: string[]
			/**
			 * Status
			 * @description Status of the batch classification job
			 */
			status: components['schemas']['ProcessingStatus']
			/**
			 * Timestamp
			 * Format: date-time
			 * @description Timestamp of the classification job
			 */
			timestamp?: string
		}
		/** ClassifyResponse */
		ClassifyResponse: {
			/**
			 * Job ID
			 * @description ID of the classification job
			 */
			jobId: string
			/**
			 * Document ID
			 * @description ID of the document classified
			 */
			documentId: string
			/**
			 * Class IDs
			 * @description List of class IDs used for classification
			 */
			classIds?: string[]
			/**
			 * Assigned Class IDs
			 * @description List of class IDs assigned to the document
			 */
			assignedClassIds?: string[]
			/**
			 * Status
			 * @description Status of the classification job
			 */
			status: components['schemas']['ProcessingStatus']
			/**
			 * Timestamp
			 * Format: date-time
			 * @description Timestamp of the classification job
			 */
			timestamp?: string
		}
		/** Classify and Standardize Step */
		ClassifyStandardizeStep: {
			/**
			 * Classids
			 * @description The ids of the classes to classify the data to. If omitted or empty list, use all classes.
			 */
			classIds?: string[]
			/**
			 * Multi-Class
			 * @description Whether the classification is multi-class or not.
			 * @default false
			 */
			multiClass: boolean
			/**
			 * Include Unknown
			 * @description Whether to include the 'unknown' class in the classification. Only relevant for if multiClass is false and classIds is not provided.
			 * @default true
			 */
			includeUnknown: boolean
			/**
			 * Instructions
			 * @description Instructions for the AI on how to classify the document.
			 */
			instructions?: string
			/**
			 * Classtoschema
			 * @description A mapping of class ID to a schema that we should standardize into. Note that not every class must be mapped to a schema, if you do not wish to standardize certain classes. Any schemas mentioned will trigger a standardize action based on the schemaId provided.
			 */
			classToSchema: {
				[key: string]: string
			}
			/**
			 * Stdreleaseversion
			 * @description The release version of the standardization, supported versions are: [1, 2]
			 * @default 2
			 */
			stdReleaseVersion: number
			/**
			 * Stdversion
			 * @description The sub-version of the standardization.
			 */
			stdVersion?: number
			/**
			 * Guidelines
			 * @description Guidelines for the AI on how to standardize the documents. If omitted, use the schema's guidelines.
			 */
			guidelines?: string
			/**
			 * Use Metadata
			 * @description Whether to use metadata during standardization.
			 */
			useMetadata?: boolean
			/**
			 * Displaymode
			 * @description The display mode of the standardization. For V1, this is called `standardizationMode`. The options are: `auto`, `spatial`, `sections`.
			 */
			displayMode?: components['schemas']['DisplayMode']
			/**
			 * Splitmode
			 * @description The split mode of the standardization. The options are: `auto`, `never`, `all`.
			 */
			splitMode?: components['schemas']['SplitMode']
			/**
			 * Effortlevel
			 * @description The effort level of the standardization. The options are: `standard`, `high`.
			 */
			effortLevel?: components['schemas']['EffortLevel']
		}
		/** ClassifyStandardizeStepOutput */
		ClassifyStandardizeStepOutput: {
			/**
			 * Classification Job ID
			 * @description Job ID for the classification job.
			 */
			classificationJobId: string
			/**
			 * Class to Standardization IDs
			 * @description Dictionary mapping class IDs to the standardization IDs that will be created for that class if the document is classified as that class.
			 */
			classToStandardizationIds: Record<string, never>
			/**
			 * Class to Standardization Job IDs
			 * @description Dictionary mapping class IDs to the job IDs for the standardization jobs that will run for that class if the document is classified as that class.
			 */
			classToStandardizationJobIds: Record<string, never>
		}
		/**
		 * Confidence
		 * @enum {string}
		 */
		Confidence: 'high' | 'medium' | 'low'
		/** CreateWebhookEndpointRequest */
		CreateWebhookEndpointRequest: {
			/**
			 * Url
			 * @description The URL of the webhook endpoint
			 */
			url: string
			/**
			 * Subscribedevents
			 * @description The events to subscribe to, if not specified, all events will be sent to the endpoint
			 */
			subscribedEvents?: components['schemas']['EventTypeEnum'][]
		}
		/** CreateWebhookEndpointResponse */
		CreateWebhookEndpointResponse: {
			/**
			 * Endpointid
			 * @description The ID which identifies the endpoint
			 */
			endpointId: string
		}
		/** DeleteAnalysesRequest */
		DeleteAnalysesRequest: {
			/**
			 * Analysis IDs
			 * @description List of analysis IDs to be deleted.
			 */
			analysisIds: string[]
		}
		/** DeleteDocumentsRequest */
		DeleteDocumentsRequest: {
			/**
			 * Document IDs
			 * @description List of document IDs to be deleted.
			 */
			documentIds: string[]
		}
		/** DeleteJobsRequest */
		DeleteJobsRequest: {
			/**
			 * Job IDs
			 * @description List of job IDs to be deleted.
			 */
			jobIds: string[]
		}
		/**
		 * DeleteReviewsRequest
		 * @description Request for the delete review endpoint
		 *
		 */
		DeleteReviewsRequest: {
			/**
			 * Review IDs
			 * @description Unique identifiers of the review objects to be deleted.
			 */
			reviewIds: string[]
		}
		/** DeleteStandardizationsRequest */
		DeleteStandardizationsRequest: {
			/**
			 * Standardization IDs
			 * @description List of standardization IDs to be deleted.
			 */
			standardizationIds: string[]
		}
		/** DeleteWebhookEndpointRequest */
		DeleteWebhookEndpointRequest: {
			/**
			 * Endpointid
			 * @description The ID which identifies the webhook endpoint
			 */
			endpointId: string
		}
		/** DeleteWebhookEndpointResponse */
		DeleteWebhookEndpointResponse: {
			/**
			 * Success
			 * @description The webhook endpoint was successfully deleted
			 * @default true
			 */
			success: boolean
		}
		/** DeletionResponse */
		DeletionResponse: {
			/**
			 * Success
			 * @description Whether the deletion was successful or not.
			 */
			success: boolean
		}
		/**
		 * DisplayMode
		 * @enum {string}
		 */
		DisplayMode: 'auto' | 'spatial' | 'sections' | 'image'
		/** DocuPandaSchema */
		DocuPandaSchema: {
			/**
			 * Schema ID
			 * @description Unique identifier of the schema.
			 */
			schemaId?: string
			/**
			 * User ID
			 * @description Unique identifier of the user who submitted the schema.
			 */
			userId: string
			/**
			 * Schema Name
			 * @description Name of the schema.
			 */
			schemaName?: string
			/**
			 * Schema
			 * @description A valid JSON schema
			 */
			jsonSchema?: Record<string, never>
			/**
			 * Guidelines
			 * @description Guidelines for the schema.
			 */
			guidelines?: string
			/**
			 * Version
			 * @description DocuPanda API version used to process the schema.
			 */
			version?: number
			/**
			 * Timestamp
			 * Format: date-time
			 * @description Timestamp of the schema creation.
			 */
			timestamp?: string
			/**
			 * Draft
			 * @description Whether the schema is a draft.
			 */
			draft?: boolean
		}
		/**
		 * Document
		 * @description Public facing version of DocuPandaDocument
		 *
		 */
		Document: {
			/**
			 * Document ID
			 * @description Unique identifier of the document.
			 */
			documentId: string
			/**
			 * Dataset
			 * @description Name of the dataset to which the document belongs.
			 */
			dataset?: string
			/**
			 * Classified
			 * @description Whether the document has been classified.
			 * @default false
			 */
			classified: boolean
			/**
			 * Class IDs
			 * @description List of class IDs assigned to the document. If classified is False, this will be None.
			 */
			classIds?: string[]
			/**
			 * Document filename
			 * @description Name of the document file.
			 */
			filename?: string
			/**
			 * File Type
			 * @description Type of the document file.
			 */
			fileType?: components['schemas']['FileType']
			/**
			 * File Extension
			 * @description Extension of the document file.
			 */
			fileExtension?: components['schemas']['FileExtension']
			/**
			 * Analysis Result
			 * @description Result of the document analysis if completed.
			 */
			result?: components['schemas']['ParsingResults']
			/**
			 * Number of Pages
			 * @description Number of pages in the document.
			 */
			numPages?: number
			/**
			 * Language
			 * @description Dominant language of the document.
			 */
			language?: string
			/**
			 * Metadata
			 * @description Metadata associated with the document. This is a user-defined dictionary that can have any properties.
			 */
			metadata?: Record<string, never>
			/**
			 * Processing Status
			 * @description Current status of the document processing (deprecated, will be removed in future versions).
			 */
			status?: components['schemas']['ProcessingStatus']
			/**
			 * Timestamp
			 * @description Timestamp of the document creation.
			 */
			timestamp?: string
		}
		/** DocumentSummary */
		DocumentSummary: {
			/**
			 * Total Documents
			 * @description Total number of documents.
			 */
			totalDocuments: number
			/**
			 * Datasets
			 * @description List of dataset names.
			 */
			datasets: string[]
		}
		/** EditSchemaRequest */
		EditSchemaRequest: {
			/**
			 * Schema ID
			 * @description Unique identifier of the schema which we are editing.
			 */
			schemaId: string
			/**
			 * Schema Name
			 * @description New name to assign to the schema.
			 */
			schemaName?: string
			/**
			 * Description
			 * @description New description to assign to the schema.
			 */
			description?: string
			/**
			 * Guidelines
			 * @description New guidelines to assign to the schema.
			 */
			guidelines?: string
		}
		/** EditSchemaResponse */
		EditSchemaResponse: {
			/**
			 * Success
			 * @description Whether the schema was successfully edited.
			 */
			success: boolean
		}
		/**
		 * EffortLevel
		 * @enum {string}
		 */
		EffortLevel: 'standard' | 'high'
		/** ErrorResponse */
		ErrorResponse: {
			/**
			 * Detail
			 * @description Details about the error
			 */
			detail: string[]
		}
		/**
		 * EventTypeEnum
		 * @enum {string}
		 */
		EventTypeEnum:
			| 'document.processed.success'
			| 'document.processed.error'
			| 'standardization.processed.success'
			| 'standardization.processed.error'
			| 'review.processed.success'
			| 'review.processed.error'
			| 'schema.processed.success'
			| 'schema.processed.error'
			| 'classification.processed.success'
			| 'classification.processed.error'
			| 'split.processed.success'
			| 'split.processed.error'
		/** File */
		File: {
			/**
			 * File Contents
			 * Format: binary
			 * @description Binary string representing the content of the file in base64 encoding.
			 */
			contents: string
		}
		/**
		 * FileExtension
		 * @enum {string}
		 */
		FileExtension: 'pdf' | 'png' | 'jpeg' | 'webp' | 'txt' | 'json' | 'html' | 'tiff' | 'doc' | 'docx'
		/**
		 * FileType
		 * @enum {string}
		 */
		FileType: 'pdf' | 'image' | 'text' | 'json' | 'html' | 'word'
		/** GetAccountResponse */
		GetAccountResponse: {
			/**
			 * Remainingcredits
			 * @description The number of remaining credits in your account under your current plan. Consuming these credits will result in no charge
			 */
			remainingCredits: number
			/**
			 * Overagecredits
			 * @description The number of overage credits in your account. These credits will be charged on your billing cycle.
			 */
			overageCredits: number
			/**
			 * Upcominginvoice
			 * @description Details of the upcoming invoice, including the total amount and the date it will be charged
			 */
			upcomingInvoice?: components['schemas']['UpcomingInvoice']
		}
		/** GetDatasetsResponse */
		GetDatasetsResponse: {
			/**
			 * Dataset Names
			 * @description List of dataset names
			 */
			datasetNames: string[]
		}
		/** GetSplitJobResponse */
		GetSplitJobResponse: {
			/**
			 * Job ID
			 * @description Unique identifier for the split job.
			 */
			jobId: string
			/**
			 * Status
			 * @description Current status of the split job.
			 */
			status: components['schemas']['ProcessingStatus']
			/**
			 * Document ID
			 * @description Unique identifier of the original document that was split.
			 */
			documentId: string
			/**
			 * Number of New Documents
			 * @description Number of new documents created from the split.
			 */
			numNewDocuments?: number
			/**
			 * New Document IDs
			 * @description List of unique identifiers of the new documents created from the split.
			 */
			newDocumentIds?: string[]
			/**
			 * Details
			 * @description Details of the split document.
			 */
			details?: Record<string, never>[]
			/**
			 * Error Message
			 * @description Error message if the job failed.
			 */
			errorMessage?: string
			/**
			 * Processing Time
			 * @description Time taken to process the split job in seconds.
			 */
			processingTime?: number
			/**
			 * Timestamp
			 * Format: date-time
			 * @description Timestamp of when the job was created.
			 */
			timestamp: string
		}
		/** HTTPValidationError */
		HTTPValidationError: {
			/** Detail */
			detail?: components['schemas']['ValidationError'][]
		}
		/**
		 * HeaderType
		 * @enum {string}
		 */
		HeaderType: 'paragraph' | 'h1' | 'h2' | 'h3' | 'h4' | 'h5' | 'h6'
		/** HealthResponse */
		HealthResponse: {
			/**
			 * Success
			 * @description Whether the request was successful or not.
			 */
			success: boolean
		}
		/** Input Document */
		InputDocument: {
			/**
			 * File
			 * @description File object containing the input document in base64 encoding.
			 */
			file?: components['schemas']['File']
			/**
			 * Document URL
			 * Format: uri
			 * @description URL pointing to the location of the input file.
			 */
			url?: string
			/**
			 * Filename
			 * @description Name of the file, not including the file extension.
			 */
			filename?: string
			/**
			 * File Extension
			 * @description Extension of the file.
			 */
			fileExtension?: components['schemas']['FileExtension']
			/**
			 * File Type
			 * @description Type of the file. If not provided, it will be determined from the file contents.
			 */
			fileType?: components['schemas']['FileType']
		}
		/** InsufficientCreditsError */
		InsufficientCreditsError: {
			/**
			 * Detail
			 * @description Explanation about the exhausted credits
			 */
			detail: string[]
		}
		/** Job */
		Job: {
			/**
			 * Job ID
			 * @description Unique identifier of the job.
			 */
			jobId: string
			/**
			 * Job Type
			 * @description Type of the job.
			 */
			jobType: string
			/**
			 * Document ID
			 * @description Unique identifier of the document.
			 */
			documentId?: string
			/**
			 * Credits
			 * @description Number of credits used by the operation.
			 */
			credits?: number
			/**
			 * Processing Status
			 * @description Current status of the job.
			 */
			status: components['schemas']['ProcessingStatus']
			/**
			 * Error Message
			 * @description Error message if the job failed.
			 */
			errorMessage?: string
			/**
			 * Processing Time
			 * @description Processing time in seconds.
			 */
			processingTime?: number
			/**
			 * Timestamp
			 * Format: date-time
			 * @description Timestamp of the job creation.
			 */
			timestamp?: string
		}
		/** JobAnalyzeData */
		JobAnalyzeData: {
			/**
			 * Job ID
			 * @description Unique identifier of the job.
			 */
			jobId: string
			/**
			 * Jobtype
			 * @default analyze-data
			 */
			jobType: string
			/**
			 * Document ID
			 * @description Unique identifier of the document.
			 */
			documentId?: string
			/**
			 * Credits
			 * @description Number of credits used by the operation.
			 */
			credits?: number
			/**
			 * Processing Status
			 * @description Current status of the job.
			 */
			status: components['schemas']['ProcessingStatus']
			/**
			 * Error Message
			 * @description Error message if the job failed.
			 */
			errorMessage?: string
			/**
			 * Processing Time
			 * @description Processing time in seconds.
			 */
			processingTime?: number
			/**
			 * Timestamp
			 * Format: date-time
			 * @description Timestamp of the job creation.
			 */
			timestamp?: string
			/** Analysis ID */
			analysisId: string
			/** Document IDs */
			documentIds?: string[]
			/** Dataset */
			dataset?: string
			/** Schema ID */
			schemaId?: string
			/** Questions to ask about the data */
			questions?: string[]
		}
		/** JobAnalyzeDocument */
		JobAnalyzeDocument: {
			/**
			 * Job ID
			 * @description Unique identifier of the job.
			 */
			jobId: string
			/**
			 * Jobtype
			 * @default analyze-document
			 */
			jobType: string
			/** Document ID */
			documentId: string
			/**
			 * Credits
			 * @description Number of credits used by the operation.
			 */
			credits?: number
			/**
			 * Processing Status
			 * @description Current status of the job.
			 */
			status: components['schemas']['ProcessingStatus']
			/**
			 * Error Message
			 * @description Error message if the job failed.
			 */
			errorMessage?: string
			/**
			 * Processing Time
			 * @description Processing time in seconds.
			 */
			processingTime?: number
			/**
			 * Timestamp
			 * Format: date-time
			 * @description Timestamp of the job creation.
			 */
			timestamp?: string
			/** Analysis ID */
			analysisId: string
			/** Pages Questioned (if missing, all pages are analyzed) */
			pages?: number[]
			/** Questions to ask about the document */
			questions?: string[]
		}
		/** JobAutogenerateSchema */
		JobAutogenerateSchema: {
			/**
			 * Job ID
			 * @description Unique identifier of the job.
			 */
			jobId: string
			/**
			 * Jobtype
			 * @default autogenerate-schema
			 */
			jobType: string
			/**
			 * Document ID
			 * @description Unique identifier of the document.
			 */
			documentId?: string
			/**
			 * Credits
			 * @description Number of credits used by the operation.
			 */
			credits?: number
			/**
			 * Processing Status
			 * @description Current status of the job.
			 */
			status: components['schemas']['ProcessingStatus']
			/**
			 * Error Message
			 * @description Error message if the job failed.
			 */
			errorMessage?: string
			/**
			 * Processing Time
			 * @description Processing time in seconds.
			 */
			processingTime?: number
			/**
			 * Timestamp
			 * Format: date-time
			 * @description Timestamp of the job creation.
			 */
			timestamp?: string
			/** Schema ID */
			schemaId: string
			/** Schema Name */
			schemaName: string
			/** Document IDs */
			documentIds?: string[]
			/** Dataset */
			dataset?: string
			/** Instructions */
			instructions?: string
			/** Guidelines */
			guidelines?: string
			/**
			 * Standardize Using Schema
			 * @default false
			 */
			standardizeUsingSchema: boolean
			/** Standardization Mode */
			standardizationMode?: components['schemas']['StdMode']
			/** Standardization IDs */
			standardizationIds?: string[]
			/** Standardization Job IDs */
			standardizationJobIds?: string[]
		}
		/** JobClassify */
		JobClassify: {
			/**
			 * Job ID
			 * @description Unique identifier of the job.
			 */
			jobId: string
			/**
			 * Jobtype
			 * @default classify
			 */
			jobType: string
			/** Document ID */
			documentId: string
			/**
			 * Credits
			 * @description Number of credits used by the operation.
			 */
			credits?: number
			/**
			 * Processing Status
			 * @description Current status of the job.
			 */
			status: components['schemas']['ProcessingStatus']
			/**
			 * Error Message
			 * @description Error message if the job failed.
			 */
			errorMessage?: string
			/**
			 * Processing Time
			 * @description Processing time in seconds.
			 */
			processingTime?: number
			/**
			 * Timestamp
			 * Format: date-time
			 * @description Timestamp of the job creation.
			 */
			timestamp?: string
			/** Class IDs */
			classIds: string[]
			/** Include Unknown */
			includeUnknown?: boolean
			/** Multi Class */
			multiClass?: boolean
			/** Assigned Class IDs */
			assignedClassIds?: string[]
		}
		/** JobClassifyBatch */
		JobClassifyBatch: {
			/**
			 * Job ID
			 * @description Unique identifier of the job.
			 */
			jobId: string
			/**
			 * Jobtype
			 * @default classify-batch
			 */
			jobType: string
			/**
			 * Document ID
			 * @description Unique identifier of the document.
			 */
			documentId?: string
			/**
			 * Credits
			 * @description Number of credits used by the operation.
			 */
			credits?: number
			/**
			 * Processing Status
			 * @description Current status of the job.
			 */
			status: components['schemas']['ProcessingStatus']
			/**
			 * Error Message
			 * @description Error message if the job failed.
			 */
			errorMessage?: string
			/**
			 * Processing Time
			 * @description Processing time in seconds.
			 */
			processingTime?: number
			/**
			 * Timestamp
			 * Format: date-time
			 * @description Timestamp of the job creation.
			 */
			timestamp?: string
			/** Document IDs */
			documentIds: string[]
			/** Class IDs */
			classIds?: string[]
			/** Include Unknown */
			includeUnknown?: boolean
			/** Multi Class */
			multiClass?: boolean
			/** Classify Job IDs */
			classifyJobIds?: string[]
		}
		/** JobCreateSchema */
		JobCreateSchema: {
			/**
			 * Job ID
			 * @description Unique identifier of the job.
			 */
			jobId: string
			/**
			 * Jobtype
			 * @default create-schema
			 */
			jobType: string
			/**
			 * Document ID
			 * @description Unique identifier of the document.
			 */
			documentId?: string
			/**
			 * Credits
			 * @description Number of credits used by the operation.
			 */
			credits?: number
			/**
			 * Processing Status
			 * @description Current status of the job.
			 */
			status: components['schemas']['ProcessingStatus']
			/**
			 * Error Message
			 * @description Error message if the job failed.
			 */
			errorMessage?: string
			/**
			 * Processing Time
			 * @description Processing time in seconds.
			 */
			processingTime?: number
			/**
			 * Timestamp
			 * Format: date-time
			 * @description Timestamp of the job creation.
			 */
			timestamp?: string
			/** Schema ID */
			schemaId: string
			/** Schema Name */
			schemaName?: string
		}
		/** JobDocumentUpload */
		JobDocumentUpload: {
			/**
			 * Job ID
			 * @description Unique identifier of the job.
			 */
			jobId: string
			/**
			 * Job Type
			 * @description Type of the job.
			 */
			jobType: string
			/**
			 * Document ID
			 * @description Unique identifier of the document.
			 */
			documentId?: string
			/**
			 * Credits
			 * @description Number of credits used by the operation.
			 */
			credits?: number
			/**
			 * Processing Status
			 * @description Current status of the job.
			 */
			status: components['schemas']['ProcessingStatus']
			/**
			 * Error Message
			 * @description Error message if the job failed.
			 */
			errorMessage?: string
			/**
			 * Processing Time
			 * @description Processing time in seconds.
			 */
			processingTime?: number
			/**
			 * Timestamp
			 * Format: date-time
			 * @description Timestamp of the job creation.
			 */
			timestamp?: string
			/** Filename */
			filename?: string
			/** File Extension */
			fileExtension?: components['schemas']['FileExtension']
			/** File Type */
			fileType?: components['schemas']['FileType']
			/** Parse Version */
			parseVersion?: number
			/** Processing Method */
			processingMethod?: components['schemas']['ProcessingMethod']
			/** Number of Pages */
			numPages?: number
			/** Pages */
			pages?: components['schemas']['AnalyzedPage'][]
			/** Language */
			language?: string
			/** Workflow ID */
			workflowId?: string
		}
		/** JobImproveSchema */
		JobImproveSchema: {
			/**
			 * Job ID
			 * @description Unique identifier of the job.
			 */
			jobId: string
			/**
			 * Jobtype
			 * @default improve-schema
			 */
			jobType: string
			/**
			 * Document ID
			 * @description Unique identifier of the document.
			 */
			documentId?: string
			/**
			 * Credits
			 * @description Number of credits used by the operation.
			 */
			credits?: number
			/**
			 * Processing Status
			 * @description Current status of the job.
			 */
			status: components['schemas']['ProcessingStatus']
			/**
			 * Error Message
			 * @description Error message if the job failed.
			 */
			errorMessage?: string
			/**
			 * Processing Time
			 * @description Processing time in seconds.
			 */
			processingTime?: number
			/**
			 * Timestamp
			 * Format: date-time
			 * @description Timestamp of the job creation.
			 */
			timestamp?: string
			/** Schema ID */
			schemaId: string
		}
		/** JobQuery */
		JobQuery: {
			/**
			 * Job ID
			 * @description Unique identifier of the job.
			 */
			jobId: string
			/**
			 * Jobtype
			 * @default query
			 */
			jobType: string
			/** Document ID */
			documentId: string
			/**
			 * Credits
			 * @description Number of credits used by the operation.
			 */
			credits?: number
			/**
			 * Processing Status
			 * @description Current status of the job.
			 */
			status: components['schemas']['ProcessingStatus']
			/**
			 * Error Message
			 * @description Error message if the job failed.
			 */
			errorMessage?: string
			/**
			 * Processing Time
			 * @description Processing time in seconds.
			 */
			processingTime?: number
			/**
			 * Timestamp
			 * Format: date-time
			 * @description Timestamp of the job creation.
			 */
			timestamp?: string
			/** Query */
			query: string
		}
		/** JobReview */
		JobReview: {
			/**
			 * Job ID
			 * @description Unique identifier of the job.
			 */
			jobId: string
			/**
			 * Jobtype
			 * @default review
			 */
			jobType: string
			/**
			 * Document ID
			 * @description Unique identifier of the document.
			 */
			documentId?: string
			/**
			 * Credits
			 * @description Number of credits used by the operation.
			 */
			credits?: number
			/**
			 * Processing Status
			 * @description Current status of the job.
			 */
			status: components['schemas']['ProcessingStatus']
			/**
			 * Error Message
			 * @description Error message if the job failed.
			 */
			errorMessage?: string
			/**
			 * Processing Time
			 * @description Processing time in seconds.
			 */
			processingTime?: number
			/**
			 * Timestamp
			 * Format: date-time
			 * @description Timestamp of the job creation.
			 */
			timestamp?: string
			/** Review ID */
			reviewId: string
			/** Standardization ID */
			standardizationId: string
		}
		/** JobSplit */
		JobSplit: {
			/**
			 * Job ID
			 * @description Unique identifier of the job.
			 */
			jobId: string
			/**
			 * Jobtype
			 * @default split
			 */
			jobType: string
			/** Document ID */
			documentId: string
			/**
			 * Credits
			 * @description Number of credits used by the operation.
			 */
			credits?: number
			/**
			 * Processing Status
			 * @description Current status of the job.
			 */
			status: components['schemas']['ProcessingStatus']
			/**
			 * Error Message
			 * @description Error message if the job failed.
			 */
			errorMessage?: string
			/**
			 * Processing Time
			 * @description Processing time in seconds.
			 */
			processingTime?: number
			/**
			 * Timestamp
			 * Format: date-time
			 * @description Timestamp of the job creation.
			 */
			timestamp?: string
			/** Number of New Documents */
			numNewDocuments?: number
			/** New Document IDs */
			newDocumentIds?: string[]
			/** Details */
			details?: Record<string, never>[]
			/** Instructions */
			instructions?: string
		}
		/** JobStandardize */
		JobStandardize: {
			/**
			 * Job ID
			 * @description Unique identifier of the job.
			 */
			jobId: string
			/**
			 * Jobtype
			 * @default standardize
			 */
			jobType: string
			/**
			 * Document ID
			 * @description Unique identifier of the document.
			 */
			documentId?: string
			/**
			 * Credits
			 * @description Number of credits used by the operation.
			 */
			credits?: number
			/**
			 * Processing Status
			 * @description Current status of the job.
			 */
			status: components['schemas']['ProcessingStatus']
			/**
			 * Error Message
			 * @description Error message if the job failed.
			 */
			errorMessage?: string
			/**
			 * Processing Time
			 * @description Processing time in seconds.
			 */
			processingTime?: number
			/**
			 * Timestamp
			 * Format: date-time
			 * @description Timestamp of the job creation.
			 */
			timestamp?: string
			/** Standardization ID */
			standardizationId: string
			/** Schema ID */
			schemaId: string
			/** Use Metadata */
			useMetadata?: boolean
			/** Standardization Mode */
			standardizationMode?: components['schemas']['StdMode']
			/** Display Mode */
			displayMode?: components['schemas']['DisplayMode']
			/** Split Mode */
			splitMode?: components['schemas']['SplitMode']
			/** Effort Level */
			effortLevel?: components['schemas']['EffortLevel']
			/** Release Version */
			releaseVersion?: number
			/** Standardization Version */
			stdVersion?: number
			/** Guidelines */
			guidelines?: string
		}
		/** JobStandardizeBatch */
		JobStandardizeBatch: {
			/**
			 * Job ID
			 * @description Unique identifier of the job.
			 */
			jobId: string
			/**
			 * Jobtype
			 * @default standardize-batch
			 */
			jobType: string
			/**
			 * Document ID
			 * @description Unique identifier of the document.
			 */
			documentId?: string
			/**
			 * Credits
			 * @description Number of credits used by the operation.
			 */
			credits?: number
			/**
			 * Processing Status
			 * @description Current status of the job.
			 */
			status: components['schemas']['ProcessingStatus']
			/**
			 * Error Message
			 * @description Error message if the job failed.
			 */
			errorMessage?: string
			/**
			 * Processing Time
			 * @description Processing time in seconds.
			 */
			processingTime?: number
			/**
			 * Timestamp
			 * Format: date-time
			 * @description Timestamp of the job creation.
			 */
			timestamp?: string
			/** Schema ID */
			schemaId?: string
			/** Document IDs */
			documentIds: string[]
			/** Document Count */
			documentCount: number
			/** Page Count */
			pageCount: number
			/** Standardization IDs */
			standardizationIds?: string[]
			/** Standardization Job IDs */
			standardizationJobIds?: string[]
		}
		/** JobSummary */
		JobSummary: {
			/**
			 * Summary All Time
			 * @description Summary of the total number of jobs and credits used by job type (deleted jobs count as well).
			 */
			summaryAllTime: {
				[key: string]: components['schemas']['JobTypeStats']
			}
			/**
			 * Summary Recent
			 * @description Summary of the recent (since last billing cycle) number of jobs and credits used by job type.
			 */
			summaryRecent: {
				[key: string]: components['schemas']['JobTypeStats']
			}
			/**
			 * Total Visible Jobs
			 * @description Total number of visible jobs (not deleted).
			 */
			totalVisibleJobs: number
		}
		/** JobTranslate */
		JobTranslate: {
			/**
			 * Job ID
			 * @description Unique identifier of the job.
			 */
			jobId: string
			/**
			 * Jobtype
			 * @default translate
			 */
			jobType: string
			/** Document ID */
			documentId: string
			/**
			 * Credits
			 * @description Number of credits used by the operation.
			 */
			credits?: number
			/**
			 * Processing Status
			 * @description Current status of the job.
			 */
			status: components['schemas']['ProcessingStatus']
			/**
			 * Error Message
			 * @description Error message if the job failed.
			 */
			errorMessage?: string
			/**
			 * Processing Time
			 * @description Processing time in seconds.
			 */
			processingTime?: number
			/**
			 * Timestamp
			 * Format: date-time
			 * @description Timestamp of the job creation.
			 */
			timestamp?: string
			/** Language */
			language: string
			/** Pages to Translate */
			pagesToTranslate?: number[]
			/** Number of Pages Translated */
			numPagesTranslated?: number
			/** Translated Text */
			translatedText?: string
		}
		/** JobTypeStats */
		JobTypeStats: {
			/** Numjobs */
			numJobs: number
			/** Numcredits */
			numCredits: number
		}
		/** JobUpdateSchema */
		JobUpdateSchema: {
			/**
			 * Job ID
			 * @description Unique identifier of the job.
			 */
			jobId: string
			/**
			 * Jobtype
			 * @default update-schema
			 */
			jobType: string
			/**
			 * Document ID
			 * @description Unique identifier of the document.
			 */
			documentId?: string
			/**
			 * Credits
			 * @description Number of credits used by the operation.
			 */
			credits?: number
			/**
			 * Processing Status
			 * @description Current status of the job.
			 */
			status: components['schemas']['ProcessingStatus']
			/**
			 * Error Message
			 * @description Error message if the job failed.
			 */
			errorMessage?: string
			/**
			 * Processing Time
			 * @description Processing time in seconds.
			 */
			processingTime?: number
			/**
			 * Timestamp
			 * Format: date-time
			 * @description Timestamp of the job creation.
			 */
			timestamp?: string
			/** Schema ID */
			schemaId: string
			/** Schema Name */
			schemaName?: string
		}
		/** MatchCandidate */
		MatchCandidate: {
			/**
			 * Id
			 * @description The id of the record
			 */
			id: string
			/**
			 * Record
			 * @description The record to be matched, can be any dictionary
			 */
			record: Record<string, never>
		}
		/** MatchingRequest */
		MatchingRequest: {
			/**
			 * Standardizationid
			 * @description The id of the standardization you're looking to match
			 */
			standardizationId: string
			/** Matchcandidates */
			matchCandidates: components['schemas']['MatchCandidate'][]
			/**
			 * Instructions
			 * @description The instructions for the match
			 */
			instructions: string
		}
		/** MatchingResponse */
		MatchingResponse: {
			/**
			 * Reasoning
			 * @description The reasoning behind the match
			 */
			reasoning: string
			/**
			 * Matchingrecords
			 * @description The records that matched in descending order of likelihood. Usually one record
			 */
			matchingRecords: components['schemas']['MatchCandidate'][]
		}
		/**
		 * OutputFormat
		 * @enum {string}
		 */
		OutputFormat: 'original' | 'pdf'
		/** ParsingResults */
		ParsingResults: {
			/**
			 * Pages
			 * @description A list of parsed pages in the document.
			 * @default []
			 */
			pages: components['schemas']['AnalyzedPage'][]
			/**
			 * Number of Pages
			 * @description The number of pages in the document.
			 * @default 0
			 */
			numPages: number
			/**
			 * Text
			 * @description The text content of the document.
			 */
			text?: string
			/**
			 * Language
			 * @description The dominant language of the document.
			 */
			language?: string
		}
		/**
		 * PostAnalyzeResponse
		 * @description Asyncronous response for analyze-document or analyze-data
		 *
		 */
		PostAnalyzeResponse: {
			/**
			 * Job ID
			 * @description Unique identifier for the submitted job.
			 */
			jobId: string
			/**
			 * Analysis ID
			 * @description Unique identifier for the analysis.
			 */
			analysisId: string
			/**
			 * Success
			 * @description Whether the job was successful launched or not.
			 */
			success: boolean
		}
		/** PostDocumentRequest */
		PostDocumentRequest: {
			/** @description The document to be analyzed, provided either as a file or via a URL. */
			document: components['schemas']['InputDocument']
			/**
			 * Pages
			 * @description List of page numbers to be parsed (zero indexed). If not provided, all pages will be parsed.
			 */
			pages?: number[]
			/**
			 * Dataset
			 * @description Name of the dataset to which you want to assign this document. It can be any string. This is useful to group your documents
			 */
			dataset?: string
			/**
			 * Metadata
			 * @description Optional metadata to associate with the document.
			 */
			metadata?: Record<string, never>
			/**
			 * Version
			 * @description Version of parsing. Available versions are 1 and 2 (default is 2).
			 */
			parseVersion?: number
			/**
			 * Processing Method
			 * @description Method to use for processing the document. The options are: asImage (treats native PDFs as images), or removeWatermark (removes watermarks from PDFs before processing). Note that removeWatermark is experimental.
			 */
			processingMethod?: components['schemas']['ProcessingMethod']
			/**
			 * Workflow ID
			 * @description *Advanced Feature*
			 *     Unique identifier of the workflow to be applied to the doucment once it is processed. See `POST /workflow/onSubmitDocument` for more details.
			 */
			workflowId?: string
		}
		/** PostDocumentResponse */
		PostDocumentResponse: {
			/**
			 * Document ID
			 * @description Unique identifier for the submitted document.
			 */
			documentId: string
			/**
			 * Job ID
			 * @description Unique identifier for the Document Upload Job.
			 */
			jobId: string
			/**
			 * Processing Status
			 * @description Current status of the document processing.
			 */
			status: components['schemas']['ProcessingStatus']
			/**
			 * Workflow Response
			 * @description *Advanced Feature*
			 *     If you supplied a workfld In the input, the response will contain all the information to retrieve the outcome of the workflow.
			 */
			workflowResponse?: components['schemas']['WorkflowResponse']
		}
		/** PostSchemaRequest */
		PostSchemaRequest: {
			/**
			 * Schema Name
			 * @description Name of the new schema.
			 */
			schemaName: string
			/**
			 * JSON Schema
			 * @description The new JSON schema to add. Must be a valid JSON schema (https://json-schema.org/).
			 */
			jsonSchema: Record<string, never>
		}
		/**
		 * PostSplitResponse
		 * @description Async response for a split job
		 *
		 */
		PostSplitResponse: {
			/**
			 * Job ID
			 * @description Unique identifier for the submitted job.
			 */
			jobId: string
			/**
			 * Timestamp
			 * Format: date-time
			 * @description Timestamp of when the job was submitted.
			 */
			timestamp?: string
			/**
			 * Success
			 * @description Whether the job was successfully submitted.
			 * @default true
			 */
			success: boolean
		}
		/** PresignedUrlResponse */
		PresignedUrlResponse: {
			/** Url */
			url: string
		}
		/**
		 * ProcessingMethod
		 * @enum {string}
		 */
		ProcessingMethod: 'asImage' | 'removeWatermark'
		/**
		 * ProcessingStatus
		 * @enum {string}
		 */
		ProcessingStatus: 'processing' | 'completed' | 'error'
		/** ProposedSchemas */
		ProposedSchemas: {
			/** Schemas */
			schemas: components['schemas']['DocuPandaSchema'][]
			/** Documentdescription */
			documentDescription: string
		}
		/** QueryRequest */
		QueryRequest: {
			/**
			 * Schema ID
			 * @description Unique identifier of the schema.
			 */
			schemaId: string
			/**
			 * Query
			 * @description Free language text explaining what documents you're after. if the text is empty
			 */
			query: string
			/**
			 * Dataset
			 * @description Name of the dataset to which the document belongs If empty, the query will run on all documents
			 */
			dataset?: string
			/**
			 * Limit
			 * @description Maximum number of documents to return. If not specified will default to 100
			 */
			limit?: number
		}
		/** QueryResponse */
		QueryResponse: {
			/**
			 * Standardizations
			 * @description List of document standardization objects that match the query.
			 * @default []
			 */
			standardizations: components['schemas']['Standardization'][]
			/**
			 * Query Feedback
			 * @description AI generated feedback on the query, which may include suggestions for improvement, ambiguities, or explanation about the query feasibility
			 */
			queryFeedback?: string | null
		}
		/** QuestionAnswer */
		QuestionAnswer: {
			/**
			 * Question
			 * @description The question to be answered.
			 */
			question: string
			/**
			 * Answer
			 * @description The answer to the question.
			 */
			answer?: string
			/**
			 * Confidence
			 * @description The confidence level of the answer.
			 */
			confidence?: components['schemas']['Confidence']
			/**
			 * Citations
			 * @description List of citations for the answer.
			 */
			citations?: components['schemas']['Citation'][]
		}
		/** RefineSchemaRequest */
		RefineSchemaRequest: {
			/**
			 * Schema ID
			 * @description Unique identifier of the schema that was used with the document to make the standardization.
			 */
			schemaId: string
			/**
			 * Feedback
			 * @description Feedback string to alter the schema.
			 */
			feedback: string
			/**
			 * Document ID
			 * @description Unique identifier of the document to use for schema refinement.
			 */
			documentId?: string
		}
		/** Review */
		Review: {
			/**
			 * Standardization ID
			 * @description Unique identifier of the standardization object.
			 */
			standardizationId: string
			/**
			 * Document ID
			 * @description Unique identifier of the document.
			 */
			documentId: string
			/**
			 * Reviewed Payload
			 * @description An exact copy of the original standardization JSON object, except every value is replaced with a dictionary with the following values:
			 *     - **value**: The original value
			 *     - **review**:
			 *        - **page**: (Under review) The page number on which the value was found
			 *        - **confidence**: (Under review) The confidence score of the value extraction
			 *        - **boundingBox**: (Under review) The bounding box of the value on the page. These will be normalized coordinates 0..1 for the page size, in the format:
			 *           - **x**: The x-coordinate (starting from the left)
			 *           - **y**: The y-coordinate (starting from the top)
			 *           - **width**: The width of the bounding box
			 *           - **height**: The height of the bounding box
			 *
			 */
			data?: Record<string, never>
			/**
			 * Schema ID
			 * @description Unique identifier of the schema used for standardization.
			 */
			schemaId?: string
			/**
			 * Schema Name
			 * @description Name of the schema used for standardization.
			 */
			schemaName?: string
			/**
			 * Job ID
			 * @description Unique identifier of the job that created the standardization.
			 */
			jobId?: string
			/**
			 * Dataset
			 * @description Name of the dataset to which the document belongs
			 */
			dataset?: string
			/**
			 * Filename
			 * @description Name of the file that was standardized.
			 */
			filename?: string
			/**
			 * Timestamp
			 * @description Timestamp of the standardization job.
			 */
			timestamp?: string
			/**
			 * Metadata
			 * @description Metadata associated with the document that originated this standardization. This just echoes any metadata you have previously posted on document creation.
			 */
			metadata?: Record<string, never>
			/**
			 * Review ID
			 * @description Unique identifier of the review object.
			 */
			reviewId?: string
		}
		/**
		 * Schema
		 * @description Public facing version of DocuPandaSchema
		 *
		 */
		Schema: {
			/**
			 * Schema ID
			 * @description Unique identifier of the schema.
			 */
			schemaId: string
			/**
			 * Schema Name
			 * @description Name of the schema.
			 */
			schemaName?: string
			/**
			 * JSON Schema
			 * @description The JSON schema that defines the structure of the data.
			 */
			jsonSchema?: Record<string, never>
			/**
			 * Guidelines
			 * @description Guidelines for the schema.
			 */
			guidelines?: string
			/**
			 * Job ID
			 * @description Unique identifier of the job that last modified the schema.
			 */
			jobId?: string
			/**
			 * Timestamp
			 * @description Timestamp of the schema creation.
			 */
			timestamp?: string
		}
		/** Section */
		Section: {
			/**
			 * Type
			 * @description The type of the section (text, table, image)
			 */
			type: components['schemas']['SectionType']
			/**
			 * Text
			 * @description The text content of the section
			 */
			text: string
			/**
			 * Bounding Box
			 * @description Bounding box of the section in the format [x1, y1, x2, y2], in percentage units [0, 1] within the page
			 */
			bbox: number[]
			/**
			 * Header Type
			 * @description For text sections, the type of header: paragraph (default), h1 - h6
			 */
			header?: components['schemas']['HeaderType']
			/**
			 * Table List
			 * @description For table sections, a list of lists representing the table. The outer list represents rows, the inner lists represent column values in those rows. The first row is the header.If there is no header, the first row is a list of empty strings.
			 */
			tableList?: string[][]
		}
		/**
		 * SectionType
		 * @enum {string}
		 */
		SectionType: 'text' | 'table' | 'image'
		/** SplitJobRequest */
		SplitJobRequest: {
			/**
			 * Document ID
			 * @description Unique identifier of the document to be split.
			 */
			documentId: string
			/**
			 * Instructions
			 * @description Instructions for how the splitting should be done (optional).
			 */
			instructions?: string
		}
		/**
		 * SplitMode
		 * @enum {string}
		 */
		SplitMode: 'auto' | 'all' | 'never'
		/**
		 * Standardization
		 * @description Public facing version of DocuPandaStandardization
		 *
		 */
		Standardization: {
			/**
			 * Standardization ID
			 * @description Unique identifier of the standardization object.
			 */
			standardizationId: string
			/**
			 * Document ID
			 * @description Unique identifier of the document.
			 */
			documentId: string
			/**
			 * Standardization Result
			 * @description The standardized result of the document. This is a structured JSON object.
			 */
			data: Record<string, never>
			/**
			 * Schema ID
			 * @description Unique identifier of the schema used for standardization.
			 */
			schemaId?: string
			/**
			 * Schema Name
			 * @description Name of the schema used for standardization.
			 */
			schemaName?: string
			/**
			 * Job ID
			 * @description Unique identifier of the job that created the standardization.
			 */
			jobId?: string
			/**
			 * Dataset
			 * @description Name of the dataset to which the document belongs
			 */
			dataset?: string
			/**
			 * Filename
			 * @description Name of the file that was standardized.
			 */
			filename?: string
			/**
			 * Timestamp
			 * @description Timestamp of the standardization job.
			 */
			timestamp?: string
			/**
			 * Metadata
			 * @description Metadata associated with the document that originated this standardization. This just echoes any metadata you have previously posted on document creation.
			 */
			metadata?: Record<string, never>
		}
		/**
		 * StandardizationReviewRequest
		 * @description Request to standardize a document
		 *
		 */
		StandardizationReviewRequest: {
			/**
			 * Standardization ID
			 * @description Unique identifier of the standardization object.
			 */
			standardizationIds: string[]
			/**
			 * Review Instructions
			 * @description Instructions for the review process. You may optionally specify which fields you want to localize, and give the AI tips to improve review performance
			 */
			reviewInstructions?: string | null
		}
		/** StandardizationSummary */
		StandardizationSummary: {
			/**
			 * Total Standardizations
			 * @description Total number of standardizations.
			 */
			totalStandardizations: number
			/**
			 * Schema Names
			 * @description List of schema names.
			 */
			schemaNames: string[]
		}
		/**
		 * StandardizationVersion
		 * @enum {numeric}
		 */
		StandardizationVersion: 2 | 2.1
		/**
		 * StandardizationXml
		 * @description Public facing version of DocuPandaStandardization, that includes the XML result
		 *
		 */
		StandardizationXml: {
			/**
			 * Standardization ID
			 * @description Unique identifier of the standardization object.
			 */
			standardizationId: string
			/**
			 * Document ID
			 * @description Unique identifier of the document.
			 */
			documentId: string
			/**
			 * Standardization Result
			 * @description The standardized result of the document. This is a structured JSON object.
			 */
			data: Record<string, never>
			/**
			 * Schema ID
			 * @description Unique identifier of the schema used for standardization.
			 */
			schemaId?: string
			/**
			 * Schema Name
			 * @description Name of the schema used for standardization.
			 */
			schemaName?: string
			/**
			 * Job ID
			 * @description Unique identifier of the job that created the standardization.
			 */
			jobId?: string
			/**
			 * Dataset
			 * @description Name of the dataset to which the document belongs
			 */
			dataset?: string
			/**
			 * Filename
			 * @description Name of the file that was standardized.
			 */
			filename?: string
			/**
			 * Timestamp
			 * @description Timestamp of the standardization job.
			 */
			timestamp?: string
			/**
			 * Metadata
			 * @description Metadata associated with the document that originated this standardization. This just echoes any metadata you have previously posted on document creation.
			 */
			metadata?: Record<string, never>
			/**
			 * XML
			 * @description The XML result of the standardization.
			 */
			xml?: string
		}
		/** StandardizeBatchResponse */
		StandardizeBatchResponse: {
			/**
			 * Job ID
			 * @description Unique identifier of the standardization job.
			 */
			jobId: string
			/**
			 * Processing Status
			 * @description Current status of the standardization job.
			 */
			status: components['schemas']['ProcessingStatus']
			/**
			 * Timestamp of last update
			 * Format: date-time
			 * @description Timestamp of the last update to the job.
			 */
			timestamp: string
			/**
			 * Document Count
			 * @description Number of documents this job will effect. Documents already standardized from previous runs will not be counted.
			 */
			documentCount: number
			/**
			 * Page Count
			 * @description Number of pages this job will effect. Pages already standardized from previous runs will not be counted.
			 */
			pageCount: number
			/**
			 * Standardization Job IDs
			 * @description List of individual standardization job IDs that were run in this batch job.
			 */
			standardizationJobIds?: string[]
			/**
			 * Standardization IDs
			 * @description List of individual standardization IDs that were created in this batch job.
			 */
			standardizationIds?: string[]
			/**
			 * Details
			 * @description Details of the status of the job.
			 */
			details?: string
		}
		/** StandardizeStep */
		StandardizeStep: {
			/**
			 * Schemaids
			 * @description The IDs of all the schemas to standardize the document into.
			 */
			schemaIds: string[]
			/**
			 * Stdreleaseversion
			 * @description The release version of the standardization, supported versions are: [1, 2]
			 * @default 2
			 */
			stdReleaseVersion: number
			/**
			 * Stdversion
			 * @description The sub-version of the standardization.
			 */
			stdVersion?: number
			/**
			 * Guidelines
			 * @description Guidelines for the AI on how to standardize the documents. If omitted, use the schema's guidelines.
			 */
			guidelines?: string
			/**
			 * Use Metadata
			 * @description Whether to use metadata during standardization.
			 */
			useMetadata?: boolean
			/**
			 * Displaymode
			 * @description The display mode of the standardization. For V1, this is called `standardizationMode`. The options are: `auto`, `spatial`, `sections`.
			 */
			displayMode?: components['schemas']['DisplayMode']
			/**
			 * Splitmode
			 * @description The split mode of the standardization. The options are: `auto`, `never`, `all`.
			 */
			splitMode?: components['schemas']['SplitMode']
			/**
			 * Effortlevel
			 * @description The effort level of the standardization. The options are: `standard`, `high`.
			 */
			effortLevel?: components['schemas']['EffortLevel']
		}
		/** StandardizeStepOutput */
		StandardizeStepOutput: {
			/**
			 * Standardization IDs
			 * @description List of standardization IDs that result from the standardize step.
			 */
			standardizationIds: string[]
			/**
			 * Job IDs
			 * @description List of job IDs for the standardization jobs that will run.
			 */
			standardizationJobIds: string[]
		}
		/** StandardizeV2BatchRequest */
		StandardizeV2BatchRequest: {
			/**
			 * Document IDs
			 * @description List of document IDs to be standardized, up to 100 per batch.
			 */
			documentIds: string[]
			/**
			 * Schema ID
			 * @description Unique identifier of the schema to be used for standardization - if not provided, one will be inferred.
			 */
			schemaId?: string
			/**
			 * Guidelines
			 * @description Guidelines to apply to the schema when standardizing. If this is provided, it will override the schema guidelines.
			 */
			guidelines?: string
			/**
			 * Use Metadata
			 * @description Whether to use metadata during standardization.
			 * @default false
			 */
			useMetadata: boolean
			/**
			 * Display Mode
			 * @description *Advanced Feature*
			 *     Mode of display to run. The options are:
			 *     `auto`: AI decides how to display the document (default)
			 *     `spatial`: Display text spatially, as it appears in the document
			 *     `sections`: Display text from top to bottom as sections, with tables appearing as markdown
			 *     `image`: Display as an image, accompanied by section view
			 * @default auto
			 */
			displayMode: components['schemas']['DisplayMode']
			/**
			 * Split Mode
			 * @description *Advanced Feature*
			 *     Mode of splitting to run. Splitting is used to extract array fields efficiently. The options are:
			 *     `auto`: AI decides how to split the document (default)
			 *     `never`: Never split the document (this could lead to errors or poor performance for large documents)
			 *     `all`: Split the document into individual pages
			 * @default auto
			 */
			splitMode: components['schemas']['SplitMode']
			/**
			 * Effort Level
			 * @description *Advanced Feature*
			 *     Level of effort to run. The options are:
			 *     `standard`: Standard effort level (default)
			 *     `high`: High effort level, for more difficult documents
			 * @default standard
			 */
			effortLevel: components['schemas']['EffortLevel']
			/**
			 * Standardization Version
			 * @description Version of the standardization job. If not provided, the latest version will be used (options are 2.0 and 2.1
			 * @default 2.1
			 */
			stdVersion: components['schemas']['StandardizationVersion']
		}
		/**
		 * StdMode
		 * @enum {string}
		 */
		StdMode: 'default' | 'sectionBased' | 'spatial'
		/** UpcomingInvoice */
		UpcomingInvoice: {
			/**
			 * Currency
			 * @description The currency of the upcoming invoice. Currently this is always USD
			 * @default USD
			 */
			currency: string
			/**
			 * Amountremaining
			 * @description The amount remaining to be charged on the upcoming invoice
			 */
			amountRemaining: string
			/**
			 * Amountpaid
			 * @description The amount that has already been paid on the upcoming invoice
			 */
			amountPaid: string
			/**
			 * Total
			 * @description The total amount that will be charged on the upcoming invoice
			 */
			total: string
			/**
			 * Enddate
			 * Format: date-time
			 * @description The date on which the upcoming invoice will be charged
			 */
			endDate: string
			/**
			 * Startdate
			 * Format: date-time
			 * @description The start date of the billing cycle for the upcoming invoice
			 */
			startDate: string
		}
		/** UpdateDatasetRequest */
		UpdateDatasetRequest: {
			/**
			 * Document IDs
			 * @description List of document IDs to update.
			 */
			documentIds: string[]
			/**
			 * Dataset
			 * @description Name of the dataset to which you want to assign these documents.
			 */
			dataset: string
		}
		/** UpdateDatasetResponse */
		UpdateDatasetResponse: {
			/**
			 * Success
			 * @description Whether the dataset update was successful.
			 * @default true
			 */
			success: boolean
		}
		/** UpdateSchemaRequest */
		UpdateSchemaRequest: {
			/**
			 * Schema ID
			 * @description Unique identifier of the schema which we are updating.
			 */
			schemaId: string
			/**
			 * Schema Name
			 * @description Name of the new schema.
			 */
			schemaName: string
			/**
			 * JSON Schema
			 * @description The new JSON schema to update. Must be a valid JSON schema (https://json-schema.org/). If not provided, the existing JSON schema will be used.
			 */
			jsonSchema?: Record<string, never>
		}
		/** ValidationError */
		ValidationError: {
			/** Location */
			loc: (string | number)[]
			/** Message */
			msg: string
			/** Error Type */
			type: string
		}
		/** WebhookPortalResponse */
		WebhookPortalResponse: {
			/**
			 * Url
			 * @description Generates a magic link for you to log on to URL to the app portal. From the portal you can configure webhook subscriptions
			 */
			url: string
		}
		/** Workflow */
		Workflow: {
			/**
			 * Workflow ID
			 * @description Unique identifier of the workflow.
			 */
			workflowId: string
			/**
			 * Workflow Contents
			 * @description The details of the workflow. Currently this will always be a dictionary with key being 'step' and value being  ClassifyStandardizeStep details or StandardizeStep details
			 */
			workflowContents: Record<string, never>
			/**
			 * Workflow Trigger
			 * @description The trigger that activates the workflow.
			 */
			workflowTrigger: Record<string, never>
			/** Workflow Name */
			workflowName?: string
		}
		/** WorkflowOnSubmitDocumentRequest */
		WorkflowOnSubmitDocumentRequest: {
			/**
			 * Standardize Step
			 * @description This step will always standardize the submitted document through one or more schemas you specify.
			 */
			standardizeStep?: components['schemas']['StandardizeStep']
			/**
			 * Classify and Standardize Step
			 * @description This step allows you to decide on a list of class IDs to classify into, and define which schemas to standardize by, conditional on the classification result. You may choose to only standardize some of the classes, or standardize the same class by multiple schemas.
			 */
			classifyStandardizeStep?: components['schemas']['ClassifyStandardizeStep']
			/**
			 * Workflowname
			 * @description Optionally name your workflow
			 */
			workflowName?: string
		}
		/** WorkflowPostResponse */
		WorkflowPostResponse: {
			/**
			 * Workflowid
			 * @description The id of the workflow that was created. Call POST `/document` with this workflowId to run it
			 */
			workflowId: string
			/**
			 * Success
			 * @description Whether the workflow was successfully created
			 */
			success: boolean
		}
		/** WorkflowResponse */
		WorkflowResponse: {
			/**
			 * Workflow ID
			 * @description Unique identifier of the workflow.
			 */
			workflowId: string
			/**
			 * Standardize Step Output
			 * @description Output of the standardize step, if applicable.
			 */
			standardizeStep?: components['schemas']['StandardizeStepOutput']
			/**
			 * Classify and Standardize Step Output
			 * @description Output of the classify and standardize step, if applicable.
			 */
			classifyStandardizeStep?: components['schemas']['ClassifyStandardizeStepOutput']
			/**
			 * Error Message
			 * @description Error message if the workflow failed.
			 */
			errorMessage?: string
		}
	}
	responses: never
	parameters: never
	requestBodies: never
	headers: never
	pathItems: never
}
export type $defs = Record<string, never>
export interface operations {
	root: {
		parameters: {
			query?: never
			header?: never
			path?: never
			cookie?: never
		}
		requestBody?: never
		responses: {
			/** @description Successful Response */
			200: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': unknown
				}
			}
		}
	}
	health_check: {
		parameters: {
			query?: never
			header?: never
			path?: never
			cookie?: never
		}
		requestBody?: never
		responses: {
			/** @description Successful Response */
			200: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['HealthResponse']
				}
			}
		}
	}
	post_document: {
		parameters: {
			query?: never
			header?: never
			path?: never
			cookie?: never
		}
		requestBody: {
			content: {
				'application/json': components['schemas']['PostDocumentRequest']
			}
		}
		responses: {
			/** @description Successful Response */
			200: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['PostDocumentResponse']
				}
			}
			/** @description Bad Request */
			400: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['ErrorResponse']
				}
			}
			/** @description Payment Required */
			402: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['InsufficientCreditsError']
				}
			}
			/** @description Not Found */
			404: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['ErrorResponse']
				}
			}
			/** @description Request Entity Too Large */
			413: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['ErrorResponse']
				}
			}
			/** @description Validation Error */
			422: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['HTTPValidationError']
				}
			}
		}
	}
	get_proposed_schemas: {
		parameters: {
			query?: never
			header?: never
			path: {
				document_id: string
			}
			cookie?: never
		}
		requestBody?: never
		responses: {
			/** @description Successful Response */
			200: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['ProposedSchemas']
				}
			}
			/** @description Bad Request */
			400: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['ErrorResponse']
				}
			}
			/** @description Validation Error */
			422: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['HTTPValidationError']
				}
			}
		}
	}
	get_document: {
		parameters: {
			query?: never
			header?: never
			path: {
				document_id: string
			}
			cookie?: never
		}
		requestBody?: never
		responses: {
			/** @description Successful Response */
			200: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['Document']
				}
			}
			/** @description Not Found */
			404: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['ErrorResponse']
				}
			}
			/** @description Validation Error */
			422: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['HTTPValidationError']
				}
			}
		}
	}
	delete_document: {
		parameters: {
			query?: never
			header?: never
			path: {
				document_id: string
			}
			cookie?: never
		}
		requestBody?: never
		responses: {
			/** @description Successful Response */
			200: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['DeletionResponse']
				}
			}
			/** @description Bad Request */
			400: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['ErrorResponse']
				}
			}
			/** @description Not Found */
			404: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['ErrorResponse']
				}
			}
			/** @description Validation Error */
			422: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['HTTPValidationError']
				}
			}
		}
	}
	download_original_url: {
		parameters: {
			query?: {
				/** @description Number of hours the URL should be valid for */
				hours?: number
				/** @description Output format of the document */
				format?: components['schemas']['OutputFormat']
			}
			header?: never
			path: {
				document_id: string
			}
			cookie?: never
		}
		requestBody?: never
		responses: {
			/** @description Successful Response */
			200: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['PresignedUrlResponse']
				}
			}
			/** @description Not Found */
			404: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['ErrorResponse']
				}
			}
			/** @description Validation Error */
			422: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['HTTPValidationError']
				}
			}
			/** @description Internal Server Error */
			500: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['ErrorResponse']
				}
			}
		}
	}
	download_ocr_url: {
		parameters: {
			query?: {
				/** @description Number of hours the URL should be valid for */
				hours?: number
			}
			header?: never
			path: {
				document_id: string
			}
			cookie?: never
		}
		requestBody?: never
		responses: {
			/** @description Successful Response */
			200: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['PresignedUrlResponse']
				}
			}
			/** @description Bad Request */
			400: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['ErrorResponse']
				}
			}
			/** @description Not Found */
			404: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['ErrorResponse']
				}
			}
			/** @description Validation Error */
			422: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['HTTPValidationError']
				}
			}
			/** @description Internal Server Error */
			500: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['ErrorResponse']
				}
			}
		}
	}
	list_documents: {
		parameters: {
			query?: {
				/** @description The dataset to filter documents by */
				dataset?: string
				/** @description The maximum number of documents to return. Maximum is 1000 */
				limit?: number
				/** @description The number of documents to skip (to paginate through the dataset) */
				offset?: number
				/** @description Whether to exclude the result payload from the response */
				exclude_payload?: boolean
			}
			header?: never
			path?: never
			cookie?: never
		}
		requestBody?: never
		responses: {
			/** @description Successful Response */
			200: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['Document'][]
				}
			}
			/** @description Bad Request */
			400: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['ErrorResponse']
				}
			}
			/** @description Validation Error */
			422: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['HTTPValidationError']
				}
			}
		}
	}
	delete_documents: {
		parameters: {
			query?: never
			header?: never
			path?: never
			cookie?: never
		}
		requestBody: {
			content: {
				'application/json': components['schemas']['DeleteDocumentsRequest']
			}
		}
		responses: {
			/** @description Successful Response */
			200: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['DeletionResponse']
				}
			}
			/** @description Bad Request */
			400: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['ErrorResponse']
				}
			}
			/** @description Not Found */
			404: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['ErrorResponse']
				}
			}
			/** @description Validation Error */
			422: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['HTTPValidationError']
				}
			}
		}
	}
	list_datasets: {
		parameters: {
			query?: never
			header?: never
			path?: never
			cookie?: never
		}
		requestBody?: never
		responses: {
			/** @description Successful Response */
			200: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['GetDatasetsResponse']
				}
			}
		}
	}
	update_documents_dataset: {
		parameters: {
			query?: never
			header?: never
			path?: never
			cookie?: never
		}
		requestBody: {
			content: {
				'application/json': components['schemas']['UpdateDatasetRequest']
			}
		}
		responses: {
			/** @description Successful Response */
			200: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['UpdateDatasetResponse']
				}
			}
			/** @description Bad Request */
			400: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['ErrorResponse']
				}
			}
			/** @description Not Found */
			404: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['ErrorResponse']
				}
			}
			/** @description Validation Error */
			422: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['HTTPValidationError']
				}
			}
		}
	}
	post_refine_schema: {
		parameters: {
			query?: never
			header?: never
			path?: never
			cookie?: never
		}
		requestBody: {
			content: {
				'application/json': components['schemas']['RefineSchemaRequest']
			}
		}
		responses: {
			/** @description Successful Response */
			200: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['Schema']
				}
			}
			/** @description Bad Request */
			400: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['ErrorResponse']
				}
			}
			/** @description Payment Required */
			402: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['InsufficientCreditsError']
				}
			}
			/** @description Unprocessable Entity */
			422: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['ErrorResponse']
				}
			}
			/** @description Internal Server Error */
			500: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['ErrorResponse']
				}
			}
		}
	}
	post_schema_autogenerate: {
		parameters: {
			query?: never
			header?: never
			path?: never
			cookie?: never
		}
		requestBody: {
			content: {
				'application/json': components['schemas']['AutoGenerateSchemaRequest']
			}
		}
		responses: {
			/** @description Successful Response */
			200: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['AutoGenerateSchemaResponse']
				}
			}
			/** @description Bad Request */
			400: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['ErrorResponse']
				}
			}
			/** @description Payment Required */
			402: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['InsufficientCreditsError']
				}
			}
			/** @description Validation Error */
			422: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['HTTPValidationError']
				}
			}
		}
	}
	get_schema_autogenerate_job: {
		parameters: {
			query?: never
			header?: never
			path: {
				job_id: string
			}
			cookie?: never
		}
		requestBody?: never
		responses: {
			/** @description Successful Response */
			200: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['AutoGenerateSchemaJobResponse']
				}
			}
			/** @description Not Found */
			404: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['ErrorResponse']
				}
			}
			/** @description Validation Error */
			422: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['HTTPValidationError']
				}
			}
		}
	}
	get_schema: {
		parameters: {
			query?: never
			header?: never
			path: {
				schema_id: string
			}
			cookie?: never
		}
		requestBody?: never
		responses: {
			/** @description Successful Response */
			200: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['Schema']
				}
			}
			/** @description Validation Error */
			422: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['HTTPValidationError']
				}
			}
		}
	}
	delete_schema: {
		parameters: {
			query?: never
			header?: never
			path: {
				schema_id: string
			}
			cookie?: never
		}
		requestBody?: never
		responses: {
			/** @description Successful Response */
			200: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['DeletionResponse']
				}
			}
			/** @description Not Found */
			404: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['ErrorResponse']
				}
			}
			/** @description Validation Error */
			422: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['HTTPValidationError']
				}
			}
		}
	}
	list_schemas: {
		parameters: {
			query?: {
				/** @description The maximum number of schemas to return. Maximum is 1000 */
				limit?: number
				/** @description The number of schemas to skip (to paginate through the data) */
				offset?: number
				/** @description Whether to exclude the jsonSchema payload */
				exclude_payload?: boolean
			}
			header?: never
			path?: never
			cookie?: never
		}
		requestBody?: never
		responses: {
			/** @description Successful Response */
			200: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['Schema'][]
				}
			}
			/** @description Validation Error */
			422: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['HTTPValidationError']
				}
			}
		}
	}
	get_standardization: {
		parameters: {
			query?: never
			header?: never
			path: {
				standardization_id: string
			}
			cookie?: never
		}
		requestBody?: never
		responses: {
			/** @description Successful Response */
			200: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['Standardization']
				}
			}
			/** @description Not Found */
			404: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['ErrorResponse']
				}
			}
			/** @description Validation Error */
			422: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['HTTPValidationError']
				}
			}
		}
	}
	delete_standardization: {
		parameters: {
			query?: never
			header?: never
			path: {
				standardization_id: string
			}
			cookie?: never
		}
		requestBody?: never
		responses: {
			/** @description Successful Response */
			200: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['DeletionResponse']
				}
			}
			/** @description Not Found */
			404: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['ErrorResponse']
				}
			}
			/** @description Validation Error */
			422: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['HTTPValidationError']
				}
			}
		}
	}
	get_standardization_xml: {
		parameters: {
			query?: never
			header?: never
			path: {
				standardization_id: string
			}
			cookie?: never
		}
		requestBody?: never
		responses: {
			/** @description Successful Response */
			200: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['StandardizationXml']
				}
			}
			/** @description Not Found */
			404: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['ErrorResponse']
				}
			}
			/** @description Validation Error */
			422: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['HTTPValidationError']
				}
			}
		}
	}
	download_excel_url: {
		parameters: {
			query?: {
				/** @description Number of hours the URL should be valid for */
				hours?: number
			}
			header?: never
			path: {
				standardization_id: string
			}
			cookie?: never
		}
		requestBody?: never
		responses: {
			/** @description Successful Response */
			200: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['PresignedUrlResponse']
				}
			}
			/** @description Not Found */
			404: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['ErrorResponse']
				}
			}
			/** @description Validation Error */
			422: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['HTTPValidationError']
				}
			}
			/** @description Internal Server Error */
			500: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['ErrorResponse']
				}
			}
		}
	}
	list_standardizations: {
		parameters: {
			query?: {
				/** @description The schema ID to filter standardizations by */
				schema_id?: string
				/** @description The ID of the document to filter standardizations by */
				document_id?: string
				/** @description The maximum number of standardizations to return. Maximum is 1000 */
				limit?: number
				/** @description The number of standardizations to skip (to paginate through the data) */
				offset?: number
				/** @description Whether to exclude the data payload in the response */
				exclude_payload?: boolean
			}
			header?: never
			path?: never
			cookie?: never
		}
		requestBody?: never
		responses: {
			/** @description Successful Response */
			200: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['Standardization'][]
				}
			}
			/** @description Bad Request */
			400: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['ErrorResponse']
				}
			}
			/** @description Validation Error */
			422: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['HTTPValidationError']
				}
			}
		}
	}
	delete_standardizations: {
		parameters: {
			query?: never
			header?: never
			path?: never
			cookie?: never
		}
		requestBody: {
			content: {
				'application/json': components['schemas']['DeleteStandardizationsRequest']
			}
		}
		responses: {
			/** @description Successful Response */
			200: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['DeletionResponse']
				}
			}
			/** @description Not Found */
			404: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['ErrorResponse']
				}
			}
			/** @description Validation Error */
			422: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['HTTPValidationError']
				}
			}
		}
	}
	list_jobs: {
		parameters: {
			query?: {
				start_date?: string
				end_date?: string
				status?: string
				job_type?: string
				limit?: number
				offset?: number
			}
			header?: never
			path?: never
			cookie?: never
		}
		requestBody?: never
		responses: {
			/** @description Successful Response */
			200: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['Job'][]
				}
			}
			/** @description Validation Error */
			422: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['HTTPValidationError']
				}
			}
		}
	}
	delete_jobs: {
		parameters: {
			query?: never
			header?: never
			path?: never
			cookie?: never
		}
		requestBody: {
			content: {
				'application/json': components['schemas']['DeleteJobsRequest']
			}
		}
		responses: {
			/** @description Successful Response */
			200: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['DeletionResponse']
				}
			}
			/** @description Validation Error */
			422: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['HTTPValidationError']
				}
			}
		}
	}
	post_standardize_batch_v2: {
		parameters: {
			query?: never
			header?: never
			path?: never
			cookie?: never
		}
		requestBody: {
			content: {
				'application/json': components['schemas']['StandardizeV2BatchRequest']
			}
		}
		responses: {
			/** @description Successful Response */
			200: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['StandardizeBatchResponse']
				}
			}
			/** @description Bad Request */
			400: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['ErrorResponse']
				}
			}
			/** @description Payment Required */
			402: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['InsufficientCreditsError']
				}
			}
			/** @description Not Found */
			404: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['ErrorResponse']
				}
			}
			/** @description Unprocessable Entity */
			422: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['ErrorResponse']
				}
			}
		}
	}
	match_standardization: {
		parameters: {
			query?: never
			header?: never
			path?: never
			cookie?: never
		}
		requestBody: {
			content: {
				'application/json': components['schemas']['MatchingRequest']
			}
		}
		responses: {
			/** @description Successful Response */
			200: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['MatchingResponse']
				}
			}
			/** @description Validation Error */
			422: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['HTTPValidationError']
				}
			}
		}
	}
	post_review_batch: {
		parameters: {
			query?: never
			header?: never
			path?: never
			cookie?: never
		}
		requestBody: {
			content: {
				'application/json': components['schemas']['StandardizationReviewRequest']
			}
		}
		responses: {
			/** @description Successful Response */
			200: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['BatchReviewResponse']
				}
			}
			/** @description Validation Error */
			422: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['HTTPValidationError']
				}
			}
		}
	}
	get_standardization_review: {
		parameters: {
			query?: {
				review_id?: string
				standardization_id?: string
			}
			header?: never
			path?: never
			cookie?: never
		}
		requestBody?: never
		responses: {
			/** @description Successful Response */
			200: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['Review']
				}
			}
			/** @description Validation Error */
			422: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['HTTPValidationError']
				}
			}
		}
	}
	list_reviews: {
		parameters: {
			query?: {
				/** @description Whether to include the data payload in the response */
				include_data?: boolean
				/** @description The maximum number of reviews to return. Maximum is 1000 */
				limit?: number
				/** @description The number of reviews to skip (to paginate through the data) */
				offset?: number
			}
			header?: never
			path?: never
			cookie?: never
		}
		requestBody?: never
		responses: {
			/** @description Successful Response */
			200: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['Review'][]
				}
			}
			/** @description Bad Request */
			400: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['ErrorResponse']
				}
			}
			/** @description Validation Error */
			422: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['HTTPValidationError']
				}
			}
		}
	}
	delete_reviews: {
		parameters: {
			query?: never
			header?: never
			path?: never
			cookie?: never
		}
		requestBody: {
			content: {
				'application/json': components['schemas']['DeleteReviewsRequest']
			}
		}
		responses: {
			/** @description Successful Response */
			200: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['DeletionResponse']
				}
			}
			/** @description Not Found */
			404: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['ErrorResponse']
				}
			}
			/** @description Validation Error */
			422: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['HTTPValidationError']
				}
			}
		}
	}
	post_schema: {
		parameters: {
			query?: never
			header?: never
			path?: never
			cookie?: never
		}
		requestBody: {
			content: {
				'application/json': components['schemas']['PostSchemaRequest']
			}
		}
		responses: {
			/** @description Successful Response */
			200: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['AddUpdateSchemaResponse']
				}
			}
			/** @description Bad Request */
			400: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['ErrorResponse']
				}
			}
			/** @description Payment Required */
			402: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['InsufficientCreditsError']
				}
			}
			/** @description Unprocessable Entity */
			422: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['ErrorResponse']
				}
			}
		}
	}
	post_update_schema: {
		parameters: {
			query?: never
			header?: never
			path?: never
			cookie?: never
		}
		requestBody: {
			content: {
				'application/json': components['schemas']['UpdateSchemaRequest']
			}
		}
		responses: {
			/** @description Successful Response */
			200: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['AddUpdateSchemaResponse']
				}
			}
			/** @description Payment Required */
			402: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['InsufficientCreditsError']
				}
			}
			/** @description Not Found */
			404: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['ErrorResponse']
				}
			}
			/** @description Unprocessable Entity */
			422: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['ErrorResponse']
				}
			}
		}
	}
	post_edit_schema: {
		parameters: {
			query?: never
			header?: never
			path?: never
			cookie?: never
		}
		requestBody: {
			content: {
				'application/json': components['schemas']['EditSchemaRequest']
			}
		}
		responses: {
			/** @description Successful Response */
			200: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['EditSchemaResponse']
				}
			}
			/** @description Payment Required */
			402: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['InsufficientCreditsError']
				}
			}
			/** @description Not Found */
			404: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['ErrorResponse']
				}
			}
			/** @description Unprocessable Entity */
			422: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['ErrorResponse']
				}
			}
		}
	}
	post_add_class: {
		parameters: {
			query?: never
			header?: never
			path?: never
			cookie?: never
		}
		requestBody: {
			content: {
				'application/json': components['schemas']['ClassAddRequest']
			}
		}
		responses: {
			/** @description Successful Response */
			200: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['ClassObject']
				}
			}
			/** @description Bad Request */
			400: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['ErrorResponse']
				}
			}
			/** @description Validation Error */
			422: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['HTTPValidationError']
				}
			}
		}
	}
	delete_class: {
		parameters: {
			query?: never
			header?: never
			path: {
				class_id: string
			}
			cookie?: never
		}
		requestBody?: never
		responses: {
			/** @description Successful Response */
			200: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['DeletionResponse']
				}
			}
			/** @description Not Found */
			404: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['ErrorResponse']
				}
			}
			/** @description Validation Error */
			422: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['HTTPValidationError']
				}
			}
		}
	}
	list_classes: {
		parameters: {
			query?: {
				include_unknown?: boolean
			}
			header?: never
			path?: never
			cookie?: never
		}
		requestBody?: never
		responses: {
			/** @description Successful Response */
			200: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['ClassObject'][]
				}
			}
			/** @description Validation Error */
			422: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['HTTPValidationError']
				}
			}
		}
	}
	post_classify_batch: {
		parameters: {
			query?: never
			header?: never
			path?: never
			cookie?: never
		}
		requestBody: {
			content: {
				'application/json': components['schemas']['ClassifyBatchRequest']
			}
		}
		responses: {
			/** @description Successful Response */
			200: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['ClassifyBatchResponse']
				}
			}
			/** @description Payment Required */
			402: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['InsufficientCreditsError']
				}
			}
			/** @description Not Found */
			404: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['ErrorResponse']
				}
			}
			/** @description Validation Error */
			422: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['HTTPValidationError']
				}
			}
		}
	}
	get_classify_job: {
		parameters: {
			query?: never
			header?: never
			path: {
				job_id: string
			}
			cookie?: never
		}
		requestBody?: never
		responses: {
			/** @description Successful Response */
			200: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['ClassifyResponse']
				}
			}
			/** @description Validation Error */
			422: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['HTTPValidationError']
				}
			}
		}
	}
	post_analyze_document: {
		parameters: {
			query?: never
			header?: never
			path?: never
			cookie?: never
		}
		requestBody: {
			content: {
				'application/json': components['schemas']['AnalyzeDocumentRequest']
			}
		}
		responses: {
			/** @description Successful Response */
			200: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['PostAnalyzeResponse']
				}
			}
			/** @description Bad Request */
			400: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['ErrorResponse']
				}
			}
			/** @description Payment Required */
			402: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['InsufficientCreditsError']
				}
			}
			/** @description Not Found */
			404: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['ErrorResponse']
				}
			}
			/** @description Validation Error */
			422: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['HTTPValidationError']
				}
			}
		}
	}
	post_analyze_data: {
		parameters: {
			query?: never
			header?: never
			path?: never
			cookie?: never
		}
		requestBody: {
			content: {
				'application/json': components['schemas']['AnalyzeDataRequest']
			}
		}
		responses: {
			/** @description Successful Response */
			200: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['PostAnalyzeResponse']
				}
			}
			/** @description Bad Request */
			400: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['ErrorResponse']
				}
			}
			/** @description Payment Required */
			402: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['InsufficientCreditsError']
				}
			}
			/** @description Not Found */
			404: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['ErrorResponse']
				}
			}
			/** @description Validation Error */
			422: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['HTTPValidationError']
				}
			}
		}
	}
	get_analysis: {
		parameters: {
			query?: never
			header?: never
			path: {
				analysis_id: string
			}
			cookie?: never
		}
		requestBody?: never
		responses: {
			/** @description Successful Response */
			200: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['Analysis']
				}
			}
			/** @description Not Found */
			404: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['ErrorResponse']
				}
			}
			/** @description Validation Error */
			422: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['HTTPValidationError']
				}
			}
		}
	}
	list_analyses: {
		parameters: {
			query?: {
				/** @description The maximum number of analyses to return. maximum is 20 */
				limit?: number
				/** @description The number of analyses to skip (to paginate through the data) */
				offset?: number
			}
			header?: never
			path?: never
			cookie?: never
		}
		requestBody?: never
		responses: {
			/** @description Successful Response */
			200: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['Analysis'][]
				}
			}
			/** @description Validation Error */
			422: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['HTTPValidationError']
				}
			}
		}
	}
	delete_analyses: {
		parameters: {
			query?: never
			header?: never
			path?: never
			cookie?: never
		}
		requestBody: {
			content: {
				'application/json': components['schemas']['DeleteAnalysesRequest']
			}
		}
		responses: {
			/** @description Successful Response */
			200: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['DeletionResponse']
				}
			}
			/** @description Not Found */
			404: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['ErrorResponse']
				}
			}
			/** @description Validation Error */
			422: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['HTTPValidationError']
				}
			}
		}
	}
	post_split: {
		parameters: {
			query?: never
			header?: never
			path?: never
			cookie?: never
		}
		requestBody: {
			content: {
				'application/json': components['schemas']['SplitJobRequest']
			}
		}
		responses: {
			/** @description Successful Response */
			200: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['PostSplitResponse']
				}
			}
			/** @description Payment Required */
			402: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['InsufficientCreditsError']
				}
			}
			/** @description Not Found */
			404: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['ErrorResponse']
				}
			}
			/** @description Validation Error */
			422: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['HTTPValidationError']
				}
			}
		}
	}
	get_split_job: {
		parameters: {
			query?: never
			header?: never
			path: {
				job_id: string
			}
			cookie?: never
		}
		requestBody?: never
		responses: {
			/** @description Successful Response */
			200: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['GetSplitJobResponse']
				}
			}
			/** @description Not Found */
			404: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['ErrorResponse']
				}
			}
			/** @description Validation Error */
			422: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['HTTPValidationError']
				}
			}
		}
	}
	post_query: {
		parameters: {
			query?: never
			header?: never
			path?: never
			cookie?: never
		}
		requestBody: {
			content: {
				'application/json': components['schemas']['QueryRequest']
			}
		}
		responses: {
			/** @description Successful Response */
			200: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['QueryResponse']
				}
			}
			/** @description Bad Request */
			400: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['ErrorResponse']
				}
			}
			/** @description Payment Required */
			402: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['InsufficientCreditsError']
				}
			}
			/** @description Unprocessable Entity */
			422: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['ErrorResponse']
				}
			}
		}
	}
	get_job: {
		parameters: {
			query?: never
			header?: never
			path: {
				job_id: string
			}
			cookie?: never
		}
		requestBody?: never
		responses: {
			/** @description Successful Response */
			200: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json':
						| components['schemas']['JobDocumentUpload']
						| components['schemas']['JobStandardize']
						| components['schemas']['JobStandardizeBatch']
						| components['schemas']['JobAnalyzeDocument']
						| components['schemas']['JobAnalyzeData']
						| components['schemas']['JobTranslate']
						| components['schemas']['JobSplit']
						| components['schemas']['JobClassify']
						| components['schemas']['JobClassifyBatch']
						| components['schemas']['JobCreateSchema']
						| components['schemas']['JobUpdateSchema']
						| components['schemas']['JobAutogenerateSchema']
						| components['schemas']['JobImproveSchema']
						| components['schemas']['JobQuery']
						| components['schemas']['JobReview']
				}
			}
			/** @description Not Found */
			404: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['ErrorResponse']
				}
			}
			/** @description Validation Error */
			422: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['HTTPValidationError']
				}
			}
			/** @description Internal Server Error */
			500: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['ErrorResponse']
				}
			}
		}
	}
	get_job_summary: {
		parameters: {
			query?: never
			header?: never
			path?: never
			cookie?: never
		}
		requestBody?: never
		responses: {
			/** @description Successful Response */
			200: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['JobSummary']
				}
			}
			/** @description Bad Request */
			400: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['ErrorResponse']
				}
			}
		}
	}
	get_document_summary: {
		parameters: {
			query?: never
			header?: never
			path?: never
			cookie?: never
		}
		requestBody?: never
		responses: {
			/** @description Successful Response */
			200: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['DocumentSummary']
				}
			}
			/** @description Bad Request */
			400: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['ErrorResponse']
				}
			}
		}
	}
	get_standardization_summary: {
		parameters: {
			query?: never
			header?: never
			path?: never
			cookie?: never
		}
		requestBody?: never
		responses: {
			/** @description Successful Response */
			200: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['StandardizationSummary']
				}
			}
			/** @description Bad Request */
			400: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['ErrorResponse']
				}
			}
		}
	}
	get_account: {
		parameters: {
			query?: never
			header?: never
			path?: never
			cookie?: never
		}
		requestBody?: never
		responses: {
			/** @description Successful Response */
			200: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['GetAccountResponse']
				}
			}
			/** @description Payment Required */
			402: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['InsufficientCreditsError']
				}
			}
			/** @description Not Found */
			404: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['ErrorResponse']
				}
			}
		}
	}
	post_workflow_on_submit_document: {
		parameters: {
			query?: never
			header?: never
			path?: never
			cookie?: never
		}
		requestBody: {
			content: {
				'application/json': components['schemas']['WorkflowOnSubmitDocumentRequest']
			}
		}
		responses: {
			/** @description Successful Response */
			200: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['WorkflowPostResponse']
				}
			}
			/** @description Bad Request */
			400: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['ErrorResponse']
				}
			}
			/** @description Payment Required */
			402: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['InsufficientCreditsError']
				}
			}
			/** @description Not Found */
			404: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['ErrorResponse']
				}
			}
			/** @description Validation Error */
			422: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['HTTPValidationError']
				}
			}
		}
	}
	list_workflows: {
		parameters: {
			query?: never
			header?: never
			path?: never
			cookie?: never
		}
		requestBody?: never
		responses: {
			/** @description Successful Response */
			200: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['Workflow'][]
				}
			}
		}
	}
	delete_workflow: {
		parameters: {
			query?: never
			header?: never
			path: {
				workflow_id: string
			}
			cookie?: never
		}
		requestBody?: never
		responses: {
			/** @description Successful Response */
			200: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['DeletionResponse']
				}
			}
			/** @description Not Found */
			404: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['ErrorResponse']
				}
			}
			/** @description Validation Error */
			422: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['HTTPValidationError']
				}
			}
		}
	}
	get_portal_link: {
		parameters: {
			query?: never
			header?: never
			path?: never
			cookie?: never
		}
		requestBody?: never
		responses: {
			/** @description Successful Response */
			200: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['WebhookPortalResponse']
				}
			}
		}
	}
	generate_endpoint: {
		parameters: {
			query?: never
			header?: never
			path?: never
			cookie?: never
		}
		requestBody: {
			content: {
				'application/json': components['schemas']['CreateWebhookEndpointRequest']
			}
		}
		responses: {
			/** @description Successful Response */
			200: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['CreateWebhookEndpointResponse']
				}
			}
			/** @description Validation Error */
			422: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['HTTPValidationError']
				}
			}
		}
	}
	delete_endpoint: {
		parameters: {
			query?: never
			header?: never
			path?: never
			cookie?: never
		}
		requestBody: {
			content: {
				'application/json': components['schemas']['DeleteWebhookEndpointRequest']
			}
		}
		responses: {
			/** @description Successful Response */
			200: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['DeleteWebhookEndpointResponse']
				}
			}
			/** @description Validation Error */
			422: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': components['schemas']['HTTPValidationError']
				}
			}
		}
	}
	webhook_readme: {
		parameters: {
			query?: never
			header?: never
			path?: never
			cookie?: never
		}
		requestBody?: never
		responses: {
			/** @description Successful Response */
			200: {
				headers: {
					[name: string]: unknown
				}
				content: {
					'application/json': unknown
				}
			}
		}
	}
}
